<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jenkins教程-集成SonarQube</title>
      <link href="/jenkins/build-jenkins-sonarqube/"/>
      <url>/jenkins/build-jenkins-sonarqube/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是SonarQube"><a href="#什么是SonarQube" class="headerlink" title="什么是SonarQube?"></a>什么是SonarQube?</h2><p>看看维基百科的说明：<br><img src="http://cdn.mjava.top/Fi9bL7TAwFmCYPt3Cz_d0TIwm9rQ" alt></p><h3 id="SonarQube与CI-CD架构图"><a href="#SonarQube与CI-CD架构图" class="headerlink" title="SonarQube与CI/CD架构图"></a>SonarQube与CI/CD架构图</h3><p><img src="http://cdn.mjava.top/FpResgoc3tny2jvGqaqudPwCwstj" alt="SonarQube与CI/CD架构图"></p><h2 id="Docker运行SonarQube"><a href="#Docker运行SonarQube" class="headerlink" title="Docker运行SonarQube"></a>Docker运行SonarQube</h2><p>简单了解之后，开始安装SonarQube.这里用Docker安装</p><blockquote><p>注：这里用mysql来存储SonarQube的数据，SonarQube7.9起已经不在支持mysql了，可以安装官方推荐的PostgreSQL</p></blockquote><a id="more"></a><ul><li>SonarQube 6.7.7</li><li>Docker-CE 19.03.1</li><li>Mysql 5.7</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接运行这个docker命令来安装，网上其他的教程有什么挂载文件什么的，我试了都会安装失败，原因还是因为权限原因，因为SonarQube不是以root用户运行的，导致没权限读写挂载出来的文件夹．</p><blockquote><p>注意：创建容器前一定要先保证你连的容器有对应的数据库</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name sonarqube -p 9099:9000 -p 9092:9092 --link=dev_mysql:mysql -e SONARQUBE_JDBC_USERNAME=app -e SONARQUBE_JDBC_PASSWORD=app -e SONARQUBE_JDBC_URL="jdbc:mysql://mysql:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false" --restart=always sonarqube:6.7.7-community</span><br></pre></td></tr></table></figure><ul><li><p>–link=dev_mysql:mysql     这个命令我链接到了我的mysql容器，dev_mysql是容器的名字，mysql是在SonarQube容器里的别名，所以链接数据库时直接用mysql这个别名就可了．</p></li><li><p>SONARQUBE_JDBC_USERNAME ：数据库的账户</p></li><li><p>SONARQUBE_JDBC_PASSWORD ：数据库密码</p></li></ul><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>安装好后直接访问<font color="orange">9099</font>端口，登录的账户和密码默认都是<font color="orange">admin</font>．首页就是这个样子的．</p><p><img src="http://cdn.mjava.top/Fs08WpcVDcL3n32MxoCNPDMtu1r5" alt></p><h2 id="Jenkins集成SonarQube"><a href="#Jenkins集成SonarQube" class="headerlink" title="Jenkins集成SonarQube"></a>Jenkins集成SonarQube</h2><p>Jenkins和SonarQube都是运行在Docker容器里的</p><h3 id="下载和安装插件"><a href="#下载和安装插件" class="headerlink" title="下载和安装插件"></a>下载和安装插件</h3><p>直接下载最新版的，然后导入，导入的方法可以看<a href="https://mjava.top/jenkins/problem-jenkins-01/">插件导入方法</a></p><ul><li>插件下载地址：<a href="https://updates.jenkins.io/download/plugins/sonar/" rel="noopener" target="_blank">https://updates.jenkins.io/download/plugins/sonar/</a></li></ul><h3 id="SonarQube生成Token"><a href="#SonarQube生成Token" class="headerlink" title="SonarQube生成Token"></a>SonarQube生成Token</h3><p>进入SonarQube管理界面</p><p>Administration-&gt;Security-&gt;Users</p><p><img src="http://cdn.mjava.top/FpFSYEgJfsJIwgNMA6tHHZtdAtpV" alt></p><p>然后随便输入一个名字，点击生成，记下Token</p><p><img src="http://cdn.mjava.top/FhTOSglZYOrP5poo_mmR3SGoobsD" alt></p><h3 id="添加全局凭证"><a href="#添加全局凭证" class="headerlink" title="添加全局凭证"></a>添加全局凭证</h3><p>类型选Secret text,然后Secret和ID输入框都填入刚才生成的Token</p><p><img src="http://cdn.mjava.top/FrKo5EjJ9-78uYbDjBpiuVkeu-_5" alt></p><h3 id="设置SonarQube-servers"><a href="#设置SonarQube-servers" class="headerlink" title="设置SonarQube servers"></a>设置SonarQube servers</h3><p>进入　系统管理-&gt;系统设置-&gt;SonarQube servers　　　　<font color="orange">设置好后点保存</font></p><blockquote><p>因为我SonarQube和Jenkins安装在同一台机器不同的Docker容器里的,所以这里URL直接填SonarQube的Docker容器的IP和端口</p></blockquote><p><img src="http://cdn.mjava.top/FpevTpJePMDg9-HSoQoSOCNORHL8" alt></p><h3 id="安装SonarQube-Scanner"><a href="#安装SonarQube-Scanner" class="headerlink" title="安装SonarQube Scanner"></a>安装SonarQube Scanner</h3><h4 id="下载压缩包"><a href="#下载压缩包" class="headerlink" title="下载压缩包"></a>下载压缩包</h4><ul><li>下载SonarQube Scanner压缩包：<a href="https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.2.0.1873-linux.zip" rel="noopener" target="_blank">SonarQube Scanner</a></li></ul><h4 id="解压到Jenkins挂载出来的目录里"><a href="#解压到Jenkins挂载出来的目录里" class="headerlink" title="解压到Jenkins挂载出来的目录里"></a>解压到Jenkins挂载出来的目录里</h4><p>只有解压到挂载出来的Jenkins的目录里，Docker容器安装的Jenkins才能读取到,<font color="orange"><strong>我这里是宿主机的/opt/jenkins挂载到了Jenkins容器里的/var/jenkins_home目录上，所以我只要解压到宿主机的/opt/jenkins目录中就可以了</strong></font></p><h4 id="Jenkins配置全局工具"><a href="#Jenkins配置全局工具" class="headerlink" title="Jenkins配置全局工具"></a>Jenkins配置全局工具</h4><p>进入　系统管理-&gt;全局工具配置-&gt;SonarQube Scanner     找到模块后点击<font color="orange">新增SonarQube Scanner</font></p><p><font color="orange">SONAR_RUNNER_HOME填你Jenkins这个Docker容器里的路径</font></p><p><img src="http://cdn.mjava.top/Fpgv2yqskGjp37mfoxHC6MGtIAPt" alt></p><h2 id="构建一个Maven项目"><a href="#构建一个Maven项目" class="headerlink" title="构建一个Maven项目"></a>构建一个Maven项目</h2><p>网上很多教程说要勾上这个选项：</p><p><img src="http://cdn.mjava.top/FsSrQCDF5O9x4sufLZkFRz40toHI" alt><br>其实这个是可选的，下面有一句话：<font color="orange">These variables are useful when configuring a SonarQube analysis using standard build steps such as Maven, Gradle, Ant, and command line scripts.This feature is not needed if you’re using “SonarQube Scanner” or “SonarScanner for MSBuild” build steps.</font></p><p>翻译过来就是：<img src="http://cdn.mjava.top/FrM7HmTx_APStJMI0OHlMQO6WL3W" alt><br>因为我们这里用的就是<font color="orange">SonarQube Scanner</font>,所以这个我们是可以不用勾上的，但是勾上也没影响；</p><h3 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h3><ul><li>具体怎么构建项目可以看：<a href="https://mjava.top/jenkins/build-jenkins-mavne/">Jenkins教程-创建Maven项目</a>,这里就不多介绍了</li></ul><h4 id="添加Execute-SonarQube-Scanner"><a href="#添加Execute-SonarQube-Scanner" class="headerlink" title="添加Execute SonarQube Scanner"></a>添加Execute SonarQube Scanner</h4><p>在原来构建的基础上加上<font color="orange">Execute SonarQube Scanner</font>，就可以了</p><p><img src="http://cdn.mjava.top/FgZ021lPaTWzgOPsG7veK1cn7lIB" alt></p><p>在<font color="orange">Analysis properties</font>里填上构建的参数</p><p><img src="http://cdn.mjava.top/FiFA65-xUZCh62Y5HfIgxQzvMx7D" alt></p><blockquote><p>唯一的项目标识符（必填）<br>sonar.projectKey =tiny-config1</p><p>项目元数据（以前是必需的，自SonarQube 6.1起是可选的）<br>sonar.projectName =tiny-config1<br>sonar.projectVersion = 1.0</p><p>源目录的路径（必需）<br>sonar.sources = srcDir1，srcDir2</p><p>测试源目录的路径（可选）<br>sonar.tests = testDir1，testDir2</p><p>Java项目编译类的路径（可选）<br>sonar.java.binaries = bin</p><p>逗号分隔的库路径列表（可选）<br>sonar.java.libraries = path / to / library.jar，path / to / classes / dir</p><p>附加参数<br>sonar.my.property =value</p></blockquote><p>保存后就可以正常构建了．</p><h4 id="错误解决（没有错误可跳过这段）"><a href="#错误解决（没有错误可跳过这段）" class="headerlink" title="错误解决（没有错误可跳过这段）"></a>错误解决（没有错误可跳过这段）</h4><p>如果在构建项目的时候,Jenkins控制台如果报一下错误，这是因为SonarQube的Java版本太低造成的<br><img src="http://cdn.mjava.top/FnTRL4pSwrKk5Xwbzobo89VKHf5m" alt></p><h5 id="升级SonarQube的Java版本"><a href="#升级SonarQube的Java版本" class="headerlink" title="升级SonarQube的Java版本"></a>升级SonarQube的Java版本</h5><p>进入SonarQube的管理台： Administration-&gt;Marketplace-&gt;SonarJava</p><blockquote><p>如果你版本没升级，右边会有个update按钮，点击就可以升级了，升级完后重启SonarQube;这边因为我已经升级过了，所以没有这个按钮</p></blockquote><p><img src="http://cdn.mjava.top/FgbCXvUiteJ9iGCCYC6qbInX0VSX" alt></p><h3 id="构建完成后"><a href="#构建完成后" class="headerlink" title="构建完成后"></a>构建完成后</h3><p>Jenkins控制台显示SUCCESS就表示构建成功了</p><p><img src="http://cdn.mjava.top/FoijfnBHiJAZ7lA7YqmdQb-bEqUF" alt></p><p>这时候就可以点击构建项目的SonarQube直接跳转到SonarQube控制台了</p><p><img src="http://cdn.mjava.top/FhXgRD7rBp5RBc2D6uBmH5mIBNKJ" alt></p><p>这里就可以看到结果了</p><p><img src="http://cdn.mjava.top/FkPydWtLuuliKAq1hc8Ex45nnTlu" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里就可以根据SonarQube的提示区改BUG了．这BUG有点多＝＿＝！.</p><p>在搭建过程中，最主要的就是那个SonarQube Scanner这个的安装了，因为Jenkins都是Docker化的，所以他可以选择自动安装，但是我这边选择自动安装却没用，所以就自己下载了SonarQube Scnner的包挂载到Jenkins容器里区，然后直接指定SonarQube Scnner的目录就可以了；</p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Jenkins </tag>
            
            <tag> SonarQube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Stream方法大全</title>
      <link href="/java/java-8-stream-method/"/>
      <url>/java/java-8-stream-method/</url>
      
        <content type="html"><![CDATA[<p><img src="http://cdn.mjava.top/blog/java_8_stream.png" alt="Stream"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组的几种初始化方式</title>
      <link href="/java/java-array-init/"/>
      <url>/java/java-array-init/</url>
      
        <content type="html"><![CDATA[<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="初始化容量"><a href="#初始化容量" class="headerlink" title="初始化容量"></a>初始化容量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义容量为5,初始值为0的int一维数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> array[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>[] array2=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="初始化值"><a href="#初始化值" class="headerlink" title="初始化值"></a>初始化值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化一维容量为5的一维数组的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span>[] array10=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> aray12[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><blockquote><p>二维数组初始化时必须要声明行数,列数可随意 </p></blockquote><h3 id="初始化容量-1"><a href="#初始化容量-1" class="headerlink" title="初始化容量"></a>初始化容量</h3><ul><li>声明了列数的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化一个5行5列的二维数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span>[][] array3=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> []array4[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> array5[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li>未声明列数的</li></ul><blockquote><p>此种方法初始化后如果要赋值的话要new一个数组,如果按照常规的方法赋值然后取值会报空指针异常</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化一个5行空列的二维数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span>[][] array6=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];</span><br><span class="line"><span class="keyword">int</span> []arra7[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];</span><br><span class="line"><span class="keyword">int</span> array8[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 赋值方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span>[][] array6=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];</span><br><span class="line">array6[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(array6[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:1</span></span><br></pre></td></tr></table></figure><h4 id="初始化值-1"><a href="#初始化值-1" class="headerlink" title="初始化值"></a>初始化值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化并赋值一个2行3列的二维数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span>[][] array13=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> []array14[]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> array15[][]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    其他像什么三维数组,多维数组初始化的方式都差不多,可以自己在IDE工具中试一下;</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate简单使用</title>
      <link href="/spring/spring-boot-resttemplate-example/"/>
      <url>/spring/spring-boot-resttemplate-example/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本文只讲常用的<strong>GET</strong> 和<strong>POST</strong>请求,其他类型的请求(如<strong>PUT</strong>，<strong>PATCH</strong>)请求方式都差不多，有兴趣的可以查看RestTemplate源码。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><blockquote><p>GET官方给了<strong>getForEntity</strong>和<strong>getForObject</strong>两种种方法，每个方法又有三个重载方法</p></blockquote><h3 id="官方源码接口"><a href="#官方源码接口" class="headerlink" title="官方源码接口"></a>官方源码接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h4><blockquote><p> 首先我写了两个接口供RestTemplate调用</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JSONObject jsonObject=<span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">"name:"</span>,<span class="string">"Mr.Zheng"</span>);</span><br><span class="line">        jsonObject.put(<span class="string">"tag:"</span>,<span class="string">"Good"</span>);</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">test2</span><span class="params">(@PathVariable String name)</span></span>&#123;</span><br><span class="line">        JSONObject jsonObject=<span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">"name:"</span>,name);</span><br><span class="line">        jsonObject.put(<span class="string">"tag:"</span>,<span class="string">"Good"</span>);</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject"></a>getForObject</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       RestTemplate template=<span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//使用URI请求</span></span><br><span class="line">       URI uri=URI.create(<span class="string">"http://localhost:8090/test"</span>);</span><br><span class="line">       String response=template.getForObject(uri, String.class);</span><br><span class="line">       System.out.println(response);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//url带参数请求 </span></span><br><span class="line">       String response2=template.getForObject(<span class="string">"http://localhost:8090/test/&#123;name&#125;"</span>,String.class,<span class="string">"hui1"</span>);</span><br><span class="line">       System.out.println(response2);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当url参数过多可以用map</span></span><br><span class="line">       Map&lt;String,String&gt; param=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       param.put(<span class="string">"name"</span>,<span class="string">"hui2"</span>);</span><br><span class="line">       String reponse3=template.getForObject(<span class="string">"http://localhost:8090/test/&#123;name&#125;"</span>,String.class,param);</span><br><span class="line">       System.out.println(reponse3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"name:"</span>:<span class="string">"Mr.Zheng"</span>,<span class="string">"tag:"</span>:<span class="string">"Good"</span>&#125;</span><br><span class="line">&#123;<span class="string">"name:"</span>:<span class="string">"hui1"</span>,<span class="string">"tag:"</span>:<span class="string">"Good"</span>&#125;</span><br><span class="line">&#123;<span class="string">"name:"</span>:<span class="string">"hui2"</span>,<span class="string">"tag:"</span>:<span class="string">"Good"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="getForEntity"><a href="#getForEntity" class="headerlink" title="getForEntity"></a>getForEntity</h4><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestTemplate template=<span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用URI请求</span></span><br><span class="line">    URI uri=URI.create(<span class="string">"http://localhost:8090/test"</span>);</span><br><span class="line">    ResponseEntity&lt;String&gt; response=template.getForEntity(uri, String.class);</span><br><span class="line">    System.out.println(response.getBody());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url带参数请求</span></span><br><span class="line">    ResponseEntity&lt;String&gt; response2=template.getForEntity(<span class="string">"http://localhost:8090/test/&#123;name&#125;"</span>,String.class,<span class="string">"hui1"</span>);</span><br><span class="line">    System.out.println(response2.getBody());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当url参数过多可以用map</span></span><br><span class="line">    Map&lt;String,String&gt; param=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    param.put(<span class="string">"name"</span>,<span class="string">"hui2"</span>);</span><br><span class="line">    ResponseEntity&lt;String&gt; reponse3=template.getForEntity(<span class="string">"http://localhost:8090/test/&#123;name&#125;"</span>,String.class,param);</span><br><span class="line">    System.out.println(reponse3.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"name:"</span>:<span class="string">"Mr.Zheng"</span>,<span class="string">"tag:"</span>:<span class="string">"Good"</span>&#125;</span><br><span class="line">&#123;<span class="string">"name:"</span>:<span class="string">"hui1"</span>,<span class="string">"tag:"</span>:<span class="string">"Good"</span>&#125;</span><br><span class="line">&#123;<span class="string">"name:"</span>:<span class="string">"hui2"</span>,<span class="string">"tag:"</span>:<span class="string">"Good"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可以看到<strong>getForEntity</strong>和<strong>getForObject</strong>的使用方法差不多，他们的区别就是</p><ul><li>getForObject只返回结果，getForEntity包装了返回的信息，可以从中获取更多关于http请求的信息，比如请求头，请求状态等</li></ul><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><blockquote><p>POST官方给了<strong>postForLocation</strong>,<strong>postForObject</strong>,<strong>postForEntity</strong>三种方法，每种又有三个重载方法</p></blockquote><h3 id="官方源码接口-1"><a href="#官方源码接口-1" class="headerlink" title="官方源码接口"></a>官方源码接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">URI <span class="title">postForLocation</span><span class="params">(String url, @Nullable Object request, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">URI <span class="title">postForLocation</span><span class="params">(String url, @Nullable Object request, Map&lt;String, ?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">URI <span class="title">postForLocation</span><span class="params">(URI url, @Nullable Object request)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(URI url, @Nullable Object request, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(URI url, @Nullable Object request, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException</span>;</span><br></pre></td></tr></table></figure><h3 id="API接口-1"><a href="#API接口-1" class="headerlink" title="API接口"></a>API接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG= LoggerFactory.getLogger(Test.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">test</span><span class="params">(@RequestBody JSONObject param)</span></span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"param:&#123;&#125;"</span>,param.toJSONString());</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/test/&#123;urlParam&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">test</span><span class="params">(@RequestBody JSONObject param,@PathVariable String urlParam)</span></span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"param:&#123;&#125;"</span>,param);</span><br><span class="line">        param.put(<span class="string">"urlParam"</span>,urlParam);</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="postForObject"><a href="#postForObject" class="headerlink" title="postForObject"></a>postForObject</h3><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestTemplate template=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">    String baseURL=<span class="string">"http://localhost:8090"</span>;</span><br><span class="line">    JSONObject param=<span class="keyword">new</span> JSONObject();</span><br><span class="line">    param.put(<span class="string">"tag"</span>,<span class="string">"this is post request!!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用URI请求</span></span><br><span class="line">    URI uri=URI.create(baseURL+<span class="string">"/test"</span>);</span><br><span class="line">    String response=template.postForObject(uri,param,String.class);</span><br><span class="line">    System.out.println(response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url带参数请求</span></span><br><span class="line">    String response2=template.postForObject(baseURL+<span class="string">"/test/&#123;urlParam&#125;"</span>,param,String.class,<span class="string">"this is urlParam"</span>);</span><br><span class="line">    System.out.println(response2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当url参数过多可以用map</span></span><br><span class="line">    Map&lt;String,String&gt; mapParam=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    mapParam.put(<span class="string">"urlParam"</span>,<span class="string">"this is map param!!"</span>);</span><br><span class="line">    String reponse3=template.postForObject(baseURL+<span class="string">"/test/&#123;urlParam&#125;"</span>,param,String.class,mapParam);</span><br><span class="line">    System.out.println(reponse3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"tag"</span>:<span class="string">"this is post request!!"</span>&#125;</span><br><span class="line">&#123;<span class="string">"tag"</span>:<span class="string">"this is post request!!"</span>,<span class="string">"urlParam"</span>:<span class="string">"this is urlParam"</span>&#125;</span><br><span class="line">&#123;<span class="string">"tag"</span>:<span class="string">"this is post request!!"</span>,<span class="string">"urlParam"</span>:<span class="string">"this is map param!!"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="postForEntity"><a href="#postForEntity" class="headerlink" title="postForEntity"></a>postForEntity</h3><blockquote><p>postForEntity和postForObject用法类似，具体这里就写了。</p></blockquote><h3 id="postForLocation"><a href="#postForLocation" class="headerlink" title="postForLocation"></a>postForLocation</h3><blockquote><p>这个请求和其他请求不一样，可以看到他返回的是URI，这里具体讲一下</p></blockquote><h4 id="新写个API接口"><a href="#新写个API接口" class="headerlink" title="新写个API接口"></a>新写个API接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UriTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG= LoggerFactory.getLogger(UriTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/uri"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uriTest</span><span class="params">(@RequestBody JSONObject param, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打印上传的参数</span></span><br><span class="line">            LOG.info(<span class="string">"requestParam:&#123;&#125;"</span>,param);</span><br><span class="line">            <span class="comment">//跳转百度</span></span><br><span class="line">            response.sendRedirect(<span class="string">"https://www.baidu.com"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            LOG.info(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestTemplate template=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">    String baseURL=<span class="string">"http://localhost:8090"</span>;</span><br><span class="line">    JSONObject param=<span class="keyword">new</span> JSONObject();</span><br><span class="line">    param.put(<span class="string">"info"</span>,<span class="string">"this is postForLocation test!!"</span>);</span><br><span class="line"></span><br><span class="line">    URI response2=template.postForLocation(baseURL+<span class="string">"/uri"</span>,param);</span><br><span class="line">    System.out.println(response2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><p><img src="http://cdn.mjava.top/blog/20191120165138.png" alt="代码运行结果"></p><h4 id="服务端日志"><a href="#服务端日志" class="headerlink" title="服务端日志"></a>服务端日志</h4><p><img src="http://cdn.mjava.top/blog/20191120165302.png" alt="服务端日志"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><strong>postForObject</strong>和<strong>postForEntity</strong>两个方法和GET请求的用法差不多，只是POST请求比GET请求多了个request请求体。而<strong>postForLocation</strong>方法一般用的比较少,一般只有后端发生301或302等跳转时用来获取跳转后的URL，方法的形参中不用定义返回的数据类型，默认是URI；</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos报[NACOS HTTP-POST]</title>
      <link href="/java/nacos-post-error/"/>
      <url>/java/nacos-post-error/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>　由于项目使用阿里的Nacos来管理项目的配置文件，今天所有使用Nacos的项目的日志都报[NACOS HTTP-POST] The maximum number of tolerable server reconnection errors has been reached这个错误。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>　查阅资料后说是连接超过了最大重试次数。Nacos有个maxRetry这个配置参数，默认是3;可是和SpringCloud整合后在application文件中找不到这个参数，只好另寻方法；</p><a id="more"></a><p>　由于项目都是Docker容器化的，先前出现过连接不到Nacos的问题,于是就查看了各个Docker容器的IP。</p><h3 id="修正Nacos的地址"><a href="#修正Nacos的地址" class="headerlink" title="修正Nacos的地址"></a>修正Nacos的地址</h3><p>　查阅后发现，是因为同事吧服务器重启了一遍，导致Docker服务也重启了，然后Docker容器里的IP全部都变了。因为同一台服务器上我们各个容器间的访问是通过Docker容器内部IP的，也就是172.16.x.x这个IP段。所以导致访问不到报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.nacos.config.server-addr=172.16.X.X     //更改到最新nacos的地址</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins插件版本太旧的更新方法</title>
      <link href="/jenkins/problem-jenkins-01/"/>
      <url>/jenkins/problem-jenkins-01/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>Jenkins的插件好多都是互相依赖的，如果有的插件版本太低，而另一个插件就会导致用不了，就会出现下面的情况：</code></pre><p><img src="http://cdn.mjava.top/blog/20191108102617.png" alt="jenkins插件管理界面"></p><p>Durable Task Plugin version 1.29 is older than required. To fix, install version 1.33 or later.</p><a id="more"></a><h2 id="查看本地已安装版本"><a href="#查看本地已安装版本" class="headerlink" title="查看本地已安装版本"></a>查看本地已安装版本</h2><p>可以看到，本地安装的版本和刚才提示的一样，是1.29版本的，刚才提示说太旧了，要更新到1.33版本。</p><p><img src="http://cdn.mjava.top/blog/20191108100855.png" alt="jenkins插件管理界面"></p><h2 id="搜索插件"><a href="#搜索插件" class="headerlink" title="搜索插件"></a>搜索插件</h2><p>当你理所应当的去这个界面准备搜索这个插件并更新时。。。。你傻了，，怎么搜不到？？？WTF</p><p><img src="http://cdn.mjava.top/blog/20191108102907.png" alt="jenkins插件管理界面"></p><p>不要慌，天无绝人之路，这里找不到，可以去另外的地方找。浏览器打开这个网站</p><p><a href="https://plugins.jenkins.io/" rel="noopener" target="_blank">Jenkins插件下载</a></p><ul><li>进入后在输入框里输入你刚才要下载的插件:</li></ul><p><img src="http://cdn.mjava.top/blog/20191108101610.png" alt="jenkins插件下载"></p><ul><li>选择对应的插件<br><img src="http://cdn.mjava.top/blog/20191108101748.png" alt="jenkins插件下载"></li></ul><ul><li>然后点击右上角<br><img src="http://cdn.mjava.top/blog/20191108101807.png" alt="jenkins插件下载"></li></ul><ul><li>下载刚才提示的1.33版本<br><img src="http://cdn.mjava.top/blog/20191108101832.png" alt="jenkins插件下载"></li></ul><ul><li>下载完成后是一个hpi文件<br><img src="http://cdn.mjava.top/blog/20191108102109.png" alt="jenkins插件下载"></li></ul><h2 id="导入插件"><a href="#导入插件" class="headerlink" title="导入插件"></a>导入插件</h2><ul><li><p>到插件管理界面，找到Upload Plugin<br><img src="http://cdn.mjava.top/blog/20191108102152.png" alt="jenkins插件下载"></p></li><li><p>然后选择刚才下载的插件，点击导入<br><img src="http://cdn.mjava.top/blog/20191108102223.png" alt="jenkins插件下载"></p></li><li><p>可以看到插件正在导入<br><img src="http://cdn.mjava.top/blog/20191108102240.png" alt="jenkins插件下载"></p></li><li><p>导入完成后，重启Jenkins就OK了<br><img src="http://cdn.mjava.top/blog/20191108102254.png" alt="jenkins插件下载"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins教程-Docker+GitLab持续部署持续集成</title>
      <link href="/jenkins/build-jenkins-ci-cd/"/>
      <url>/jenkins/build-jenkins-ci-cd/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="https://mjava.top/jenkins/build-jenkins-docker/">Jenkins教程-搭建(Docker版)</a></p></li><li><p><a href="https://mjava.top/jenkins/build-jenkins-mavne/">Jenkins教程-创建Maven项目</a></p></li><li><p><a href="https://mjava.top/jenkins/build-jenkins-ci-cd/">Jenkins教程-Docker+GitLab持续部署持续集成</a></p></li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table><thead><tr><th></th><th>地址</th><th>系统</th><th>安装的软件</th></tr></thead><tbody><tr><td>主机１</td><td>10.25.0.72</td><td>Centos 7</td><td>Docker　,　Jenkins(Docker版)</td></tr><tr><td>主机２</td><td>10.25.0.50</td><td>Cnetos 7</td><td>Docker</td></tr></tbody></table><a id="more"></a><h2 id="Jenkins所需添加插件"><a href="#Jenkins所需添加插件" class="headerlink" title="Jenkins所需添加插件"></a>Jenkins所需添加插件</h2><ul><li><p><a href="https://plugins.jenkins.io/git-parameter" rel="noopener" target="_blank">Git Parameter</a></p></li><li><p><a href="https://plugins.jenkins.io/gitlab-plugin" rel="noopener" target="_blank">GitLab</a></p></li><li><p><a href="https://plugins.jenkins.io/ssh" rel="noopener" target="_blank">SSH</a></p></li></ul><h2 id="创建ssh登录凭据"><a href="#创建ssh登录凭据" class="headerlink" title="创建ssh登录凭据"></a>创建ssh登录凭据</h2><p><img src="http://cdn.mjava.top/blog/20191112111043.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112111058.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112111115.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112111130.png" alt="Jenkins界面"></p><blockquote><p>这边选择Username with password,用账户密码来设置；然后在Username和Password输入框中分别输入10.25.0.50服务器的账号和密码。点击OK保存；</p></blockquote><p><img src="http://cdn.mjava.top/blog/20191112111529.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112111806.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112160316.png" alt="Jenkins界面"></p><h2 id="添加SSH配置"><a href="#添加SSH配置" class="headerlink" title="添加SSH配置"></a>添加SSH配置</h2><p><img src="http://cdn.mjava.top/blog/20191112160521.png" alt="Jenkins界面"></p><blockquote><p>找到SSH remote hosts </p></blockquote><p><img src="http://cdn.mjava.top/blog/20191112160541.png" alt="Jenkins界面"></p><blockquote><p>设置你远程机器的ip和端口，然后选择刚配置好的凭证，点击save保存</p></blockquote><p><img src="http://cdn.mjava.top/blog/20191112160920.png" alt="Jenkins界面"></p><h2 id="配置Job"><a href="#配置Job" class="headerlink" title="配置Job"></a>配置Job</h2><blockquote><p>进入上篇文章创建好的Job,在此基础上进行改造</p></blockquote><h3 id="配置Git-Parameter-来获取gitlab的Tag数据"><a href="#配置Git-Parameter-来获取gitlab的Tag数据" class="headerlink" title="配置Git Parameter,来获取gitlab的Tag数据"></a>配置Git Parameter,来获取gitlab的Tag数据</h3><p><img src="http://cdn.mjava.top/blog/20191112161424.png" alt="Jenkins界面"></p><h3 id="配置触发器"><a href="#配置触发器" class="headerlink" title="配置触发器"></a>配置触发器</h3><blockquote><p>点击最下面的Generate,生成秘钥。然后记下URL:<a href="http://172.16.54.131:8080/project/JenkinsTest" rel="noopener" target="_blank">http://172.16.54.131:8080/project/JenkinsTest</a> 和生成的秘钥：60327d68d10f1f7621696edd42719d1c</p></blockquote><p><img src="http://cdn.mjava.top/blog/20191112161808.png" alt="Jenkins界面"></p><h3 id="添加构建完成后的动作"><a href="#添加构建完成后的动作" class="headerlink" title="添加构建完成后的动作"></a>添加构建完成后的动作</h3><p><img src="http://cdn.mjava.top/blog/20191112161842.png" alt="Jenkins界面"></p><h3 id="添加Execute-shell-和Execute-shell-script-on-remote-host-using-ssh"><a href="#添加Execute-shell-和Execute-shell-script-on-remote-host-using-ssh" class="headerlink" title="添加Execute shell 和Execute shell script on remote host using ssh"></a>添加Execute shell 和Execute shell script on remote host using ssh</h3><ul><li>Execute shell ： 执行Jenkins所在服务器的脚本</li><li>Execute shell script on remote host using ssh：登录远程服务器执行脚本</li></ul><p><img src="http://cdn.mjava.top/blog/20191112161940.png" alt="Jenkins界面"></p><h3 id="编写你要执行的脚本"><a href="#编写你要执行的脚本" class="headerlink" title="编写你要执行的脚本"></a>编写你要执行的脚本</h3><blockquote><p>由于是自定义的，内容我就不粘贴出来了.编写好后点击保存</p></blockquote><p><img src="http://cdn.mjava.top/blog/20191112164613.png" alt="Jenkins界面"></p><h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><h3 id="手动构建"><a href="#手动构建" class="headerlink" title="手动构建"></a>手动构建</h3><p><img src="http://cdn.mjava.top/blog/20191112164653.png" alt="Jenkins界面"></p><h4 id="选择你要构建的tag标签，点击Build开始构建并自动部署"><a href="#选择你要构建的tag标签，点击Build开始构建并自动部署" class="headerlink" title="选择你要构建的tag标签，点击Build开始构建并自动部署"></a>选择你要构建的tag标签，点击Build开始构建并自动部署</h4><p><img src="http://cdn.mjava.top/blog/20191112164746.png" alt="Jenkins界面"></p><h3 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h3><blockquote><p>自动构建是当你push或打tag上传代码的时候，Jenkins就会自动构建部署</p></blockquote><h4 id="自动构建流程"><a href="#自动构建流程" class="headerlink" title="自动构建流程"></a>自动构建流程</h4><p><img src="http://cdn.mjava.top/blog/201911121717.png" alt="Jenkins界面"></p><p>####　配置GitLab代码仓库</p><blockquote><p>点击你你项目右边Settings的Integrations,然后在URL和Secret Tonken中填写刚保存的URL和秘钥，选择Tag push events,然后点击保存</p></blockquote><p><img src="http://cdn.mjava.top/blog/20191112165036.png" alt="Jenkins界面"></p><p>　</p><h4 id="Git打Tag标签"><a href="#Git打Tag标签" class="headerlink" title="Git打Tag标签"></a>Git打Tag标签</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a 1.0 -m '1.0'  //打一个1.0的tag</span><br><span class="line">git push origin 1.0 //上传1.0标签到远程仓库</span><br></pre></td></tr></table></figure><p>上传完tag后此时Jenkins已经开始自动构建并部署项目了；</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>弄自动部署时，Jenkins和GitLab要都能互相访问的到，不然就会出错；</p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins教程-创建Maven项目</title>
      <link href="/jenkins/build-jenkins-mavne/"/>
      <url>/jenkins/build-jenkins-mavne/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="https://mjava.top/jenkins/build-jenkins-docker/">Jenkins教程-搭建(Docker版)</a></p></li><li><p><a href="https://mjava.top/jenkins/build-jenkins-mavne/">Jenkins教程-创建Maven项目</a></p></li><li><p><a href="https://mjava.top/jenkins/build-jenkins-ci-cd/">Jenkins教程-Docker+GitLab持续部署持续集成</a></p></li></ul><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>本教程是和gitlab集成,所以要有gitlab仓库。注意：如果后期要弄自动部署的话,你Jenkins的地址gitlab必须能访问到。不然gitlab监听到事件就通知不了Jenkins了；</p><a id="more"></a><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Centos 7</li><li>Jenkins(Docker版)</li></ul><h3 id="所需插件"><a href="#所需插件" class="headerlink" title="所需插件"></a>所需插件</h3><blockquote><p>除了搭建Jenkins时安装的插件,还需安装的插件</p></blockquote><ul><li><a href="https://plugins.jenkins.io/maven-plugin" rel="noopener" target="_blank">Maven Integration</a></li></ul><h3 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h3><p>点击侧边栏的Manage Jenkins,然后点击Global Tool Configuration,进入全局工具设置<br><img src="http://cdn.mjava.top/blog/20191112105932.png" alt="Jenkins界面"></p><p>然后找到Maven,点击Add Maven,可以选择你要的Maven版本，然后设置一个名字。点击保存</p><p><img src="http://cdn.mjava.top/blog/20191112110029.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112110130.png" alt="Jenkins界面"></p><h3 id="创建Git登录凭证"><a href="#创建Git登录凭证" class="headerlink" title="创建Git登录凭证"></a>创建Git登录凭证</h3><p>点击侧边栏的凭证，然后按图点击<br><img src="http://cdn.mjava.top/blog/20191112111043.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112111058.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112111115.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112111130.png" alt="Jenkins界面"></p><p>这边Kind有很多选项，这边选择Username with password,用账户密码来设置；然后在Username和Password输入框中分别输入gitlab的账号和密码。点击OK保存；</p><p><img src="http://cdn.mjava.top/blog/20191112111529.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112111806.png" alt="Jenkins界面"></p><p>保存后就会出现你保存好的凭证；</p><h2 id="创建JOB"><a href="#创建JOB" class="headerlink" title="创建JOB"></a>创建JOB</h2><p><img src="http://cdn.mjava.top/blog/20191112111950.png" alt="Jenkins界面"></p><h3 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h3><p><img src="http://cdn.mjava.top/blog/20191112112035.png" alt="Jenkins界面"></p><h3 id="输入你的gitlab项目地址，然后选择刚才配置的凭证"><a href="#输入你的gitlab项目地址，然后选择刚才配置的凭证" class="headerlink" title="输入你的gitlab项目地址，然后选择刚才配置的凭证"></a>输入你的gitlab项目地址，然后选择刚才配置的凭证</h3><p><img src="http://cdn.mjava.top/blog/20191112112620.png" alt="Jenkins界面"></p><h3 id="输入Maven打包命令，然后点击保存"><a href="#输入Maven打包命令，然后点击保存" class="headerlink" title="输入Maven打包命令，然后点击保存"></a>输入Maven打包命令，然后点击保存</h3><p><img src="http://cdn.mjava.top/blog/20191112112719.png" alt="Jenkins界面"></p><h3 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h3><p><img src="http://cdn.mjava.top/blog/20191112112747.png" alt="Jenkins界面"></p><h3 id="查看构建项目日志"><a href="#查看构建项目日志" class="headerlink" title="查看构建项目日志"></a>查看构建项目日志</h3><blockquote><p>第一次构建会比慢，因为他要下载maven相关构建的包</p></blockquote><p><img src="http://cdn.mjava.top/blog/20191112112803.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112112841.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112112854.png" alt="Jenkins界面"></p><h3 id="查看构建好的jar包"><a href="#查看构建好的jar包" class="headerlink" title="查看构建好的jar包"></a>查看构建好的jar包</h3><p><img src="http://cdn.mjava.top/blog/20191112122030.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112122112.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112122135.png" alt="Jenkins界面"><br><img src="http://cdn.mjava.top/blog/20191112122200.png" alt="Jenkins界面"></p><blockquote><p>到此，构建maven项目已结束，可以下载这个jar包进行部署。后面会有自动构建部署的教程</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins初始化界面插件安装失败解决方法</title>
      <link href="/jenkins/problem-jenkins-02/"/>
      <url>/jenkins/problem-jenkins-02/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在初始化安装界面可能由于网络问题会出现插件下载失败，就像下面这个界面</p><p><img src="http://cdn.mjava.top/blog/jenkins_error_2_20191107155729.png" alt="Jenkins插件安装失败"></p><p>别着急，直接点击继续，先完成初始化步骤。</p><h2 id="设置源"><a href="#设置源" class="headerlink" title="设置源"></a>设置源</h2><ul><li>插件下载失败，一般都是网络的原因，只要更换到国内的软件源就可以了，点击Manage Jenkins<br><img src="http://cdn.mjava.top/blog/20191107162947.png" alt="Jenkins"></li></ul><ul><li>点击Correct<br><img src="http://cdn.mjava.top/blog/20191107163016.png" alt="Jenkins"></li></ul><ul><li>点击Advanced<br><img src="http://cdn.mjava.top/blog/20191107163040.png" alt="Jenkins"></li></ul><ul><li>下拉找到Update Site<br><img src="http://cdn.mjava.top/blog/20191107163100.png" alt="Jenkins"></li></ul><ul><li>然后把输入框的内容换成</li></ul><a id="more"></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/2.89/update-center.json</span><br></pre></td></tr></table></figure><p><img src="http://cdn.mjava.top/blog/20191107165325.png" alt="Jenkins"></p><h2 id="重新下载插件"><a href="#重新下载插件" class="headerlink" title="重新下载插件"></a>重新下载插件</h2><ul><li>然后重新下载刚才那些下载失败的插件,这里随机选一个<br><img src="http://cdn.mjava.top/blog/20191107165630.png" alt="Jenkins"></li></ul><ul><li>在刚才设置源的那个界面点击 Available，搜索插件，选择，点击install<br><img src="http://cdn.mjava.top/blog/20191107165916.png" alt="Jenkins"></li></ul><ul><li>插件正在安装<br><img src="http://cdn.mjava.top/blog/20191107165947.png" alt="Jenkins"></li></ul><blockquote><p>安装完全部插件后然后重启Jenkins，插件界面的报错信息才会消失;如果遇到插件下载不下来或搜不到，可以看这篇文章：<a href="https://mjava.top/jenkins/problem-jenkins-01/">Jenkins插件版本太旧的更新方法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins教程-搭建(Docker版)</title>
      <link href="/jenkins/build-jenkins-docker/"/>
      <url>/jenkins/build-jenkins-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="https://mjava.top/jenkins/build-jenkins-docker/">Jenkins教程-搭建(Docker版)</a></p></li><li><p><a href="https://mjava.top/jenkins/build-jenkins-mavne/">Jenkins教程-创建Maven项目</a></p></li><li><p><a href="https://mjava.top/jenkins/build-jenkins-ci-cd/">Jenkins教程-Docker+GitLab持续部署持续集成</a></p></li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><p>主机：172.16.54.131</p></li><li><p>系统：Cnetos 7</p></li></ul><h2 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker-CE"></a>安装Docker-CE</h2><h3 id="检查Docker"><a href="#检查Docker" class="headerlink" title="检查Docker"></a>检查Docker</h3><p>首先检查本机是否安装Docker，如果安装了直接跳过安装Docker步骤</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><blockquote><p>如果出现Docker version 19.03.4, build 9013bf583a类似的信息，则说明已安装Docker</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>本教程以centos7安装方式说明，其他系统安装方式会有不同</li></ul><p>执行以下命令，安装Docker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">yum install docker-ce</span><br><span class="line"></span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><ul><li>第一条命令：为添加源做准备 使其支持存储</li><li>第二条命令：添加docker-ce软件源</li><li>第三条命令：安装docker-ce</li><li>第四条命令：启动docker服务</li><li>第五条命令：设置开启自启</li></ul><h2 id="安装Jenkins的Docker容器"><a href="#安装Jenkins的Docker容器" class="headerlink" title="安装Jenkins的Docker容器"></a>安装Jenkins的Docker容器</h2><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><p>在创建容器前先在宿主机创建一个Jenkins的工作文件夹，用于持久化</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/jenkins     //创建文件夹</span><br><span class="line">chmod 7777 /opt/jenkins//授予权限</span><br></pre></td></tr></table></figure><blockquote><p>该文件夹一定要给权限，不然docker容器访问不了，容器会创建失败。</p></blockquote><h3 id="拉取官方镜像"><a href="#拉取官方镜像" class="headerlink" title="拉取官方镜像"></a>拉取官方镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkins/jenkins:lts</span><br></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 -p 50000:50000 -u root -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker -v /opt/jenkins:/var/jenkins_home -v /etc/localtime:/etc/localtime -e JAVA_OPTS=-Duser.timezone=Asia/Shanghai --restart=always --name jenkins jenkins/jenkins:lts</span><br></pre></td></tr></table></figure><blockquote><p>启动容器一定要用root用户进入docker容器，不然访问不了宿主机的docker服务。还有要挂载/var/run/docker.sock和$(which docker)这两个文件夹到容器，这样docker版的jenkins才可以用使用docker相关服务。 </p></blockquote><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs jenkins</span><br></pre></td></tr></table></figure><p><img src="http://cdn.mjava.top/blog/jenkins_docker_logs_4345.png" alt="log界面"></p><blockquote><p>记下43455b344f904cf69a4af9e231f7d48d这个密码，等下要用到</p></blockquote><h2 id="初始化Jenkins"><a href="#初始化Jenkins" class="headerlink" title="初始化Jenkins"></a>初始化Jenkins</h2><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>在浏览器访问172.16.54.131:8080这个地址，进入Jenkins的web界面。（如果访问不了，请开启防火墙的8080端口）</p><p><img src="http://cdn.mjava.top/blog/jenkins_web_sign_in_201911071359.png" alt="jenkins界面"></p><p>在输入框中填入刚才保存的密码</p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>推荐直接选 安装推荐的插件</p><p><img src="http://cdn.mjava.top/blog/jenkins_setupwizard_1911071408.png" alt="Jenkins自定义界面"></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>到这个界面等他安装完成，时间会长一点</p><p><img src="http://cdn.mjava.top/blog/jenkins_191107141216.png" alt="Jenkins安装插件"></p><blockquote><p>如这个界面插件下载失败，直接点继续，进行下一步，具体解决办法可以看这个篇文章</p><p><a href="https://mjava.top/2019/11/07/technology/learningExperience/Linux/Jenkins/Jenkins%E5%88%9D%E5%A7%8B%E5%8C%96%E7%95%8C%E9%9D%A2%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Jenkins初始化界面插件安装失败解决方法</a></p></blockquote><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>设置你的登录账号和密码，然后点保存完成<br><img src="http://cdn.mjava.top/blog/jenkins_20191107160016.png" alt="Jenkins创建用户"></p><h3 id="实例配置"><a href="#实例配置" class="headerlink" title="实例配置"></a>实例配置</h3><p>默认直接点保存完成<br><img src="http://cdn.mjava.top/blog/jenkins_20191107160056.png" alt="Jenkins实例配置"></p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>点击开始使用Jenkins<br><img src="http://cdn.mjava.top/blog/jenkins_20191107160129.png" alt="Jenkins开始使用"></p><h3 id="Jenkins主界面"><a href="#Jenkins主界面" class="headerlink" title="Jenkins主界面"></a>Jenkins主界面</h3><p>进入Jenkins主界面，到此教程结束<br><img src="http://cdn.mjava.top/blog/jenkins_20191107160204.png" alt="Jenkins主界面"></p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式系例-单例模式</title>
      <link href="/gof/gof-singleton/"/>
      <url>/gof/gof-singleton/</url>
      
        <content type="html"><![CDATA[<p>​    网上说单例模式是所有模式中最简单的一种模式，巧的是我也这么认为。不过越简单的东西，往往坑就隐藏的越深，这边文章我会把我知道的几个坑所出来。</p><h2 id="一-什么是单例模式"><a href="#一-什么是单例模式" class="headerlink" title="一.什么是单例模式"></a>一.什么是单例模式</h2><p>​    就如同他的名字一样，’单例’-就是只有一个实例。也就是说一个类在全局中最多只有一个实例存在，不能在多了，在多就不叫单例模式了。</p><a id="more"></a><h3 id="1-白话小故事"><a href="#1-白话小故事" class="headerlink" title="1.白话小故事"></a>1.白话小故事</h3><p>​    程序员小H单身已久，每天不是对着电脑，就是抱着手机这样来维持生活。某日，坐在电脑前，突然感觉一切都索然无味。谋生想找一个对象来一起度过人生美好的每一天。</p><p>​    于是精心打扮出门找对象，由于小H很帅，很快就找到了心仪的另一半–小K。小H的心中永远只有小K一个人，而且发誓永远不会在找新对象。</p><blockquote><p>小H和小K的关系就是单例模式，在小H的全局中只有一个小K对象，且无第二个，如果有第二个的话，他们之间的关系就出问题了。哈哈</p></blockquote><h2 id="2-用在哪里"><a href="#2-用在哪里" class="headerlink" title="2.用在哪里"></a>2.用在哪里</h2><p>​    单例模式一般用在对实例数量有严格要求的地方，比如数据池，线程池，缓存，session回话等等。</p><h2 id="3-在Java中构成的条件"><a href="#3-在Java中构成的条件" class="headerlink" title="3.在Java中构成的条件"></a>3.在Java中构成的条件</h2><ul><li>静态变量</li><li>静态方法</li><li>私有构造器</li></ul><h2 id="二-单例模式的两种形态"><a href="#二-单例模式的两种形态" class="headerlink" title="二.单例模式的两种形态"></a>二.单例模式的两种形态</h2><h3 id="1-懒汉模式"><a href="#1-懒汉模式" class="headerlink" title="1.懒汉模式"></a>1.懒汉模式</h3><blockquote><p>线程不安全</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton unsingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(unsingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            unsingleton=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-饿汉模式"><a href="#2-饿汉模式" class="headerlink" title="2.饿汉模式"></a>2.饿汉模式</h3><blockquote><p>线程安全</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton unsingleton=<span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton1=Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-懒汉模式优化成线程安全"><a href="#三-懒汉模式优化成线程安全" class="headerlink" title="三.懒汉模式优化成线程安全"></a>三.懒汉模式优化成线程安全</h2><p>  懒汉模式要变成线程安全的除了用饿汉模式之外，还有两种方法。</p><h3 id="1-加synchronized关键字"><a href="#1-加synchronized关键字" class="headerlink" title="1.加synchronized关键字"></a>1.加synchronized关键字</h3><blockquote><p>此方法是最简单又有效的方法，不过对性能上会有所损失。比如两个线程同时调用这个实例，其中一个线程要等另一个线程调用完才可以继续调用。而线程不安全往往发生在这个实例在第一次调用的时候发生，当实例被调用一次后，线程是安全的，所以加synchronized就显得有些浪费性能。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton unsingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(unsingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            unsingleton=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-用”双重检查加锁”"><a href="#2-用”双重检查加锁”" class="headerlink" title="2.用”双重检查加锁”"></a>2.用”双重检查加锁”</h3><blockquote><p>上个方法说到，线程不安全往往发生在这个实例在第一次调用的时候发生，当实例被调用一次后，线程是安全的。那有没有方法只有在第一次调用的时候才用synchronized关键字，而第一次后就不用synchronized关键字呢？答案是当然有的，就是用volatile来修饰静态变量，保持其可见性。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton unsingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(unsingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//只有当第一次访问的时候才会使用synchronized关键字</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                unsingleton=<span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种线程安全的单例模式比较"><a href="#三种线程安全的单例模式比较" class="headerlink" title="三种线程安全的单例模式比较"></a>三种线程安全的单例模式比较</h2><ul><li><p>饿汉模式：性能好，写法简单，个人比较推荐用这个</p></li><li><p>加synchronized关键字：性能差，不过对懒汉模式的盖章比较直接有效。</p></li><li><p>volatile-双重验证加锁：性能好，对Java版本有要求，要求Java5以上版本</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> GOF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOF </tag>
            
            <tag> Singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ集群搭建</title>
      <link href="/rocketmq/rocketmq-cluster-build/"/>
      <url>/rocketmq/rocketmq-cluster-build/</url>
      
        <content type="html"><![CDATA[<p>  本文只讲RocketMQ集群的搭建(异步复制)，具体理论知识后续会在写新文章详细介绍;</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>JDK1.8</li><li>Centos7</li></ul><h2 id="主机-两台"><a href="#主机-两台" class="headerlink" title="主机-两台"></a>主机-两台</h2><ul><li>centos7_1 :172.16.54.130</li><li>centos7_2 :172.16.54.128</li></ul><h2 id="软件资源"><a href="#软件资源" class="headerlink" title="软件资源"></a>软件资源</h2><ul><li>JDK1.8 :<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" rel="noopener" target="_blank">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li>RocketMQ4.5.2 :<a href="http://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.5.2/rocketmq-all-4.5.2-bin-release.zip" rel="noopener" target="_blank">http://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.5.2/rocketmq-all-4.5.2-bin-release.zip</a></li></ul><a id="more"></a><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>  首先分别在两台主机上安装JDK1.8，具体安装方法这里就不说了，网上随便搜一搜都有；</p><h2 id="配置RocketMQ"><a href="#配置RocketMQ" class="headerlink" title="配置RocketMQ"></a>配置RocketMQ</h2><p>  把下载的RocketMQ包分别上传到两台服务器上，然后用命令解压:</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> unzip rocketmq-all-4.5.2-bin-release.zip</span><br></pre></td></tr></table></figure><h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><p>  这一步很重要，集群的搭建关键在于配置文件的编写，首先看看RocketMq配置文件的解析:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#所属集群名字 </span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"></span><br><span class="line">#broker名字，每队master和slave保持一致</span><br><span class="line">brokerName=broker-a</span><br><span class="line"></span><br><span class="line">#0 表示 Master，&gt;0 表示 Slave</span><br><span class="line">brokerId=0 </span><br><span class="line"></span><br><span class="line">#指定主机ip</span><br><span class="line">brokerIP1 = 主机IP</span><br><span class="line"></span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=主机IP:9876;主机IP:9876</span><br><span class="line"></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数 </span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"></span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 </span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"></span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 </span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line"></span><br><span class="line">#Broker 对外服务的监听端口 </span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line"> deleteWhen=04</span><br><span class="line"></span><br><span class="line">#文件保留时间，默认 48 小时 </span><br><span class="line">fileReservedTime=120</span><br><span class="line"></span><br><span class="line">#commitLog每个文件的大小默认1G </span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"></span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"></span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line">#commitLog 存储路径 </span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line"></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE </span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘 flushDiskType=ASYNC_FLUSH</span><br><span class="line">#checkTransactionMessageEnable=false</span><br><span class="line"></span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/usr/javawork/apache-rocketmq/store/abort</span><br><span class="line"></span><br><span class="line">#限制的消息大小 maxMessageSize=65536</span><br></pre></td></tr></table></figure><p>以上配置可根据个人需求加入到自己的配置文件中；RocketMQ官方已经为我们创建好了简单的集群配置文件，进去解压后的文件夹，在进入到conf文件夹，可以看到里面有三个文件夹：</p><ul><li>2m-2s-async :2个master，2个slave，async异步复制</li><li>2m-2s-sync :2个master，2个slave，sync同步双写</li><li>2m-noslave :2个master,没有slave</li></ul><p>这里我们用async异步复制模式，进入文件夹，分别编辑：</p><h4 id="centos7-1主机编辑如下两个配置文件"><a href="#centos7-1主机编辑如下两个配置文件" class="headerlink" title="centos7_1主机编辑如下两个配置文件"></a>centos7_1主机编辑如下两个配置文件</h4><blockquote><p>注意，master和slave的文件存储路径不能用同一个路径，所以必须要区分开。</p></blockquote><h5 id="broker-a-properties"><a href="#broker-a-properties" class="headerlink" title="broker-a.properties"></a>broker-a.properties</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=0</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=172.16.54.128:9876;172.16.54.130:9876</span><br><span class="line">listenPort=10911</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/master/store</span><br><span class="line">#commitLog 存储路径 </span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/master/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/master/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/master/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/master/store/checkpoint</span><br></pre></td></tr></table></figure><p><em>这个监听端口设置设置成10911后还会自动监听10909,10912这两个端口，所以要配置文件要避免设置到相应的端口。</em></p><h5 id="broker-a-s-properties"><a href="#broker-a-s-properties" class="headerlink" title="broker-a-s.properties"></a>broker-a-s.properties</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=1</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=SLAVE</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=172.16.54.128:9876;172.16.54.130:9876</span><br><span class="line">listenPort=20911</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/slave/store</span><br><span class="line">#commitLog 存储路径 </span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/slave/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/slave/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/slave/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/slave/store/checkpoint</span><br></pre></td></tr></table></figure><p><em>这个监听端口设置设置成20911后还会自动监听20909,20912这两个端口，所以要配置文件要避免设置到相应的端口。</em></p><h4 id="centos7-2主机编辑如下两个配置文件"><a href="#centos7-2主机编辑如下两个配置文件" class="headerlink" title="centos7_2主机编辑如下两个配置文件"></a>centos7_2主机编辑如下两个配置文件</h4><h5 id="和centos7-1主机配置一样，这边就不写了，不过brokerName要设置成不同的，我这边设置成broker-b。"><a href="#和centos7-1主机配置一样，这边就不写了，不过brokerName要设置成不同的，我这边设置成broker-b。" class="headerlink" title="和centos7_1主机配置一样，这边就不写了，不过brokerName要设置成不同的，我这边设置成broker-b。"></a>和centos7_1主机配置一样，这边就不写了，不过brokerName要设置成不同的，我这边设置成broker-b。</h5><h2 id="设置RocketMQ运行的JVM内存-非必须"><a href="#设置RocketMQ运行的JVM内存-非必须" class="headerlink" title="设置RocketMQ运行的JVM内存(非必须)"></a>设置RocketMQ运行的JVM内存(非必须)</h2><blockquote><p>此项设置非必须，如果你主机内存很大的话可以不设置，RocketMQ默认要8G。</p></blockquote><p>  进入rocketmq-all-4.5.2-bin-release/bin目录，两台主机分别设置runbroker.sh和runserver.sh这两个文件。</p><ul><li>runbroker.sh：找到如下一行配置</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g&quot;</span><br><span class="line"></span><br><span class="line">改成：</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m&quot;</span><br></pre></td></tr></table></figure><ul><li>runserver.sh: 找到如下一行配置</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br><span class="line"></span><br><span class="line">改成：</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure><h2 id="启动RocketMQ"><a href="#启动RocketMQ" class="headerlink" title="启动RocketMQ"></a>启动RocketMQ</h2><blockquote><p>启动RocketMQ前为了方便访问，先关闭两台主机的防火墙。执行如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> # service firewalld stop</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p>  进入rocketmq-all-4.5.2-bin-release/bin这个目录，两台主机分别执行以下命令：</p><ul><li>启动namesrv</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure><ul><li>启动broker-master</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> nohup sh mqbroker -c ../conf/2m-2s-async/broker-a.properties &amp;</span><br></pre></td></tr></table></figure><ul><li>启动broker-slave</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> nohup sh mqbroker -c ../conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure><p><em>注意两台主机启动broker时后面的-c记得加载你配置好的配置文件路径，别加载错了</em></p><h2 id="搭建Console可视化控制台"><a href="#搭建Console可视化控制台" class="headerlink" title="搭建Console可视化控制台"></a>搭建Console可视化控制台</h2><p>  任意一台机器或者本地下载Console源码，地址：<a href="https://github.com/apache/rocketmq-externals，或者有git的话直接用命令拉取：" rel="noopener" target="_blank">https://github.com/apache/rocketmq-externals，或者有git的话直接用命令拉取：</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> git clone https://github.com/apache/rocketmq-externals.git</span><br></pre></td></tr></table></figure><p>进去目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> cd rocketmq-externals-master/rocketmq-console</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> vim src/main/resources/application.properties</span><br></pre></td></tr></table></figure><p>添加两个namesvr的主机ip</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr=172.16.54.128:9876;172.16.54.130:9876</span><br></pre></td></tr></table></figure><p>然后进项目跟目录，运行项目</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> mvn sprint-boot:run</span><br></pre></td></tr></table></figure><p>浏览器访问：</p><p><img src="http://cdn.mjava.top/blog/rocketmq_console.png" alt="可视化Console界面"></p>]]></content>
      
      
      <categories>
          
          <category> RocketMq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Cli3-11创建项目慢的问题</title>
      <link href="/vue/vue-cli3-11-problem/"/>
      <url>/vue/vue-cli3-11-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  这几天刚学习vue，于是下载了最新的vue cli3.11来搭建项目，可是搭建的时候一直卡在下载插件见面，就是下面这张图。</p><p><img src="/images/vuecreate.png" alt="vuecreate"></p><p>网上查了说不能用国内的镜像，WTF，不是说国内的更快吗？好吧，我换！！！</p><h2 id="下载nrm"><a href="#下载nrm" class="headerlink" title="下载nrm"></a>下载nrm</h2><p>  看清楚哦，是nrm部署npm！！！nrm 是一个 <code>npm</code> 源管理器，允许你快速地在 <code>npm</code> 源间切换。执行以下命令安装。</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install -g nrm</span><br></pre></td></tr></table></figure><h3 id="测试nrm是否安装成功"><a href="#测试nrm是否安装成功" class="headerlink" title="测试nrm是否安装成功"></a>测试nrm是否安装成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nrm -V</span><br></pre></td></tr></table></figure><p>如果输出版本号，则说明安装成功。</p><h2 id="切换npm源"><a href="#切换npm源" class="headerlink" title="切换npm源"></a>切换npm源</h2>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure><p>此命令会列出npm的所有源</p><p><img src="/images/nrmls.png" alt="nrmls"></p><p>可以看到我现在使用的是淘宝的源，现在把他切换到npm的源。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nrm use npm</span><br></pre></td></tr></table></figure><p><img src="/images/nrmuse.png" alt="nrmuse"></p><h2 id="再次创建vue项目"><a href="#再次创建vue项目" class="headerlink" title="再次创建vue项目"></a>再次创建vue项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue create rrr2</span><br></pre></td></tr></table></figure><p><img src="/images/vuecreate2.png" alt="vuecreate2"><br><img src="/images/vuecreate3.png" alt="vuecreate3"></p><p>项目成功创建！！！</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pit </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker下安装mysql并设置用户权限</title>
      <link href="/docker/docker-mysql/"/>
      <url>/docker/docker-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><p>Ubuntu18.04</p></li><li><p>Docker19.03.1</p></li><li><p>Mysql5.7</p></li></ul><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>  Docker拉取镜像默认是从DockerHub上面拉取，上面有各厂商提供的优质官方镜像，可以直接拉取使用。或者也可以用DockerFile自定义构建你自己的镜像。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull mysql:5.7//拉取镜像到本地</span><br></pre></td></tr></table></figure><a id="more"></a><p>注：上面mysql:5.7指的是拉取5.7版本的mysql，如果不加直接写mysql的话默认是拉取mysql的最新版本。</p><p><img src="http://cdn.mjava.top/blog/dockerpullmysql.png" alt="拉取镜像"></p><p>如果显示上面这样，说明已经拉取好了。</p><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker images//查看本地镜像</span><br></pre></td></tr></table></figure><p><img src="http://cdn.mjava.top/blog/dockerimages.png" alt="查看本地镜像"></p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -d -p 3306:3306 --name mysql5.7 -e MYSQL_ROOT_PASSWORD=root mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>-d       指定容器运行于后台</li><li>-p       端口映射   主机端口:容器端口</li><li>–name    自定义容器名字，方便记忆，不设置的话会随机生产</li><li>-e        容器环境变量</li></ul><p><img src="http://cdn.mjava.top/blog/dockerrun.png" alt="创建容器"></p><p>创建好的话会显示一串随机生产的id</p><h4 id="查看创建好的容器"><a href="#查看创建好的容器" class="headerlink" title="查看创建好的容器"></a>查看创建好的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure><ul><li>-a        显示所有创建好的容器，如果不加只显示正在运行的容器</li></ul><p><img src="http://cdn.mjava.top/blog/dockerps.png" alt="查看容器"></p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it mysql5.7 bash</span><br></pre></td></tr></table></figure><ul><li>-i        打开STDIN，用于控制台交互</li><li>-t        分配tty设备，该可以支持终端登录</li></ul><p><img src="http://cdn.mjava.top/blog/dockerexec.png" alt="进入容器"></p><h3 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>注：然后输入刚才创建容器时的密码，就是MYSQL_ROOT_PASSWORD这个参数</p><h3 id="创建测试数据库"><a href="#创建测试数据库" class="headerlink" title="创建测试数据库"></a>创建测试数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><h3 id="创建mysql用户"><a href="#创建mysql用户" class="headerlink" title="创建mysql用户"></a>创建mysql用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'zmh'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'zmh'</span>;</span><br></pre></td></tr></table></figure><p>注：”%”表示可以任意ip访问</p><h3 id="切换mysql用户"><a href="#切换mysql用户" class="headerlink" title="切换mysql用户"></a>切换mysql用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">'zmh'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'zmh'</span>;</span><br></pre></td></tr></table></figure><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权test库的所有表的所有权限给zmh用户</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> test.* <span class="keyword">to</span> <span class="string">'zmh'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><h3 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><p>退出mysql命令行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="客户端连接测试"><a href="#客户端连接测试" class="headerlink" title="客户端连接测试"></a>客户端连接测试</h3><p><img src="http://cdn.mjava.top/blog/sqlclient.png" alt="进入容器"></p><p>成功！</p><h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h2><p>如果要重启mysql的话，不用进容器里面，直接重启容器就可以</p><ul><li>sudo docker start mysql5.7       启动mysql5.7容器</li><li>sudo docker stop mysql5.7        停止mysql5.7容器</li><li>sudo docker restart mysql5.7   重启mysql5.7容器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Mysql </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装docker</title>
      <link href="/linux/build-docker-pi/"/>
      <url>/linux/build-docker-pi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  和平常x86_64架构的电脑安装docker不同，树莓派是ARM架构的，所以安装步骤比较繁琐一点。</p><h2 id="使用APT源安装docker"><a href="#使用APT源安装docker" class="headerlink" title="使用APT源安装docker"></a>使用APT源安装docker</h2><p>  更新apt软件源及安装必备组件。为了确认所下载软件包的合法性，还需要添加软件源的 GPG 密钥。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span>sudo apt-get update</span><br><span class="line"><span class="meta">$</span>sudo apt-get install \</span><br><span class="line"> apt-transport-https \</span><br><span class="line">     ca-certificates \</span><br><span class="line">     curl \</span><br><span class="line">     gnupg2 \</span><br><span class="line">     lsb-release \</span><br><span class="line">     software-properties-common</span><br><span class="line"><span class="meta">$</span>curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/raspbian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="添加docker-ce-软件源"><a href="#添加docker-ce-软件源" class="headerlink" title="添加docker ce 软件源"></a>添加docker ce 软件源</h2><ul><li><p>首先执行以下一行命令，然后记一下输出的结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> echo $(lsb_release -cs)</span><br><span class="line">stretch</span><br></pre></td></tr></table></figure></li><li><p>在/etc/apt/sources.list.d目录下新建文件docker.list</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo vi /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure></li><li><p>在文件里添加下面这行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb [arch=armhf] https://download.docker.com/linux/raspbian $(lsb_release -cs) stable</span><br></pre></td></tr></table></figure></li><li><p>把$(lsb_release -cs)改为刚才第一行输出的结果，比如我的输出的是stretch，改完后如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb [arch=armhf] https://download.docker.com/linux/raspbian stretch stable</span><br></pre></td></tr></table></figure></li><li><p>保存，退出</p></li></ul><h2 id="安装docker-ce"><a href="#安装docker-ce" class="headerlink" title="安装docker ce"></a>安装docker ce</h2><p>  依次执行以下两行命令，即可完成安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get update</span><br><span class="line"><span class="meta">$</span> sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> service docker start           启动</span><br><span class="line"><span class="meta">$</span> service docker stop            停止</span><br><span class="line"><span class="meta">$</span> service docker status          状态</span><br><span class="line"><span class="meta">$</span> service docker restart         重启</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
            <tag> RaspberryPi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK时区问题</title>
      <link href="/linux/problem-jdk-timezone/"/>
      <url>/linux/problem-jdk-timezone/</url>
      
        <content type="html"><![CDATA[<p>今天碰到一个大坑，弄了快一个小时才解决掉；</p><p>一个管理台后端服务，用docker隔离了三个容器，oracle,nginx,tomcat;后发现管理台查出来的时间和现实时间相差8个小时，一查是linux时区问题；</p><hr><ul><li>于是改之,三台容器都输入一下代码</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><a id="more"></a><p>测试了一下，发现问题docker容器的时区是正确了，可是问题并未得到解决，数据库时间还是慢了8个小时。</p><hr><ul><li>于是又查资料，换另外一种设置时区的方法；</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/clock</span><br></pre></td></tr></table></figure><p>在里面输入如下内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZONE="Asia/Shanghai"</span><br><span class="line">UTC=false</span><br><span class="line">ARC=false</span><br></pre></td></tr></table></figure><p>保存，重启，测试。。。。。发现还是一样,快疯了</p><hr><ul><li>第三种方法，设置TZ环境变量</li></ul><blockquote><p>设置环境变量可以在设置系统级别的/etc/profile  ,也可以设置用户级别的home目录的.bashrc。由于用的是docker，防止变量重启失效，只能在.bashrc里设置。在.bashrc加入如下内容：</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TZ='CST-8'</span><br></pre></td></tr></table></figure><p>保存：然后执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><p>使设置立即生效。</p><p>重启容器，测试，发现时间正常了。。。。哈哈哈哈</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面问题出在jdk的new Date()方法，所以只要设置jdk所在的那个docker容器的变量就可以，不用每个都设置。jdk的new Date()方法每次调用都会去取环境变量TZ的时区，TZ是TimeZone的缩写，容器内部操作系统并未指定时区（TimeZone）信息，系统默认使用世界标准时（UTC+0),所以导致new Date()出来的数据存库会比当前时间慢8个小时；</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的==和equals</title>
      <link href="/java/java-equals/"/>
      <url>/java/java-equals/</url>
      
        <content type="html"><![CDATA[<p>在平常工作和学习中，我们一般用==和equals来比较两个对象或数据是否相等。但是什么时候用equals，什么时候用==一直都不怎么清楚，今天整理了下；</p><h2 id="首先看看Java的栈空间和堆空间的地址引用"><a href="#首先看看Java的栈空间和堆空间的地址引用" class="headerlink" title="首先看看Java的栈空间和堆空间的地址引用"></a>首先看看Java的栈空间和堆空间的地址引用</h2><p><img src="http://cdn.mjava.top/blog/javaand1.png" alt="Java栈空间和堆空间"></p><h2 id="的说明"><a href="#的说明" class="headerlink" title="==的说明"></a>==的说明</h2><p>  在Java中，==对比的是两个对象在空间里的地址是否一致,比如上图的s2==s3返回的是false，s5==s6返回的是为true。话不多说，上代码。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="keyword">new</span> String(<span class="string">"t1"</span>);</span><br><span class="line">        String s2=<span class="keyword">new</span> String(<span class="string">"t2"</span>);</span><br><span class="line">        String s3=<span class="keyword">new</span> String(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        String s4=<span class="keyword">new</span> String(<span class="string">"t3"</span>);</span><br><span class="line">        String s5=<span class="string">"t3"</span>;</span><br><span class="line">        String s6=<span class="string">"t3"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s2==s3:"</span>+(s2==s3));</span><br><span class="line">        System.out.println(<span class="string">"s5==s6:"</span>+(s5==s6));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="http://cdn.mjava.top/blog/javaand2.png" alt="控制台输出"></p><blockquote><p>这是因为==比的是在空间里的地址，s2和s3在堆里面是两个不同的对象，所以地址也不同，自然返回就是false。s5和s6是Java的基础数据类型，指向的是常量池里同一个引用，所以地址也相同，返回的就是true。</p></blockquote><h2 id="equals的说明"><a href="#equals的说明" class="headerlink" title="equals的说明"></a>equals的说明</h2><p>  每个Object里的equals都不一样，我们看看String里的源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先它会对比地址，如果地址相等，就直接返回true</li><li>如果地址不相等，就会对比里面的每一个字符，直到完全相等，然后返回true</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　所以一般如果是对比两个对象是否相等的话，用==就可以。但是如果你要对比两个值是否相等的话，就要用equals了，因为如果用==就会出现上面明明值相等,返回却是false的情况。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中String判断为空的4大方法比较</title>
      <link href="/java/java-isnull-four/"/>
      <url>/java/java-isnull-four/</url>
      
        <content type="html"><![CDATA[<h2 id="一-四大方法"><a href="#一-四大方法" class="headerlink" title="一.四大方法"></a>一.四大方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String a=<span class="string">""</span>;</span><br><span class="line">       String a2=<span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line">       System.out.println(a==<span class="string">""</span>);</span><br><span class="line">       System.out.println(a2==<span class="string">""</span>);</span><br><span class="line">       System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">       System.out.println(a==<span class="keyword">null</span>);</span><br><span class="line">       System.out.println(a2==<span class="keyword">null</span>);</span><br><span class="line">       System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">       System.out.println(a.length()&lt;=<span class="number">0</span>);</span><br><span class="line">       System.out.println(a2.length()&lt;=<span class="number">0</span>);</span><br><span class="line">       System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">       System.out.println(a.isEmpty());</span><br><span class="line">       System.out.println(a2.isEmpty());</span><br><span class="line">       System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二-输出结果"><a href="#二-输出结果" class="headerlink" title="二.输出结果"></a>二.输出结果</h2><p><img src="http://cdn.mjava.top/blog/javaands1.png" alt="控制台输出"></p><blockquote><p>可以看到用”==”判断的那组出现了不一致的情况</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Integer和int区别</title>
      <link href="/java/java-integer-int/"/>
      <url>/java/java-integer-int/</url>
      
        <content type="html"><![CDATA[<h2 id="1-两者本质区别"><a href="#1-两者本质区别" class="headerlink" title="1.两者本质区别"></a>1.两者本质区别</h2><p>  int是Java的基础数据类型之一，而Integer是基于int进行封装的一个对象</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归算法-获取json中指定key的所有值</title>
      <link href="/algorithm/algorithm-recursive-01/"/>
      <url>/algorithm/algorithm-recursive-01/</url>
      
        <content type="html"><![CDATA[<p>今天在工作中遇到要解析json并获取json里所有指定key的值，再把key的值插入对应的数据映射表。于是写了一个递归算法来取值。</p><h2 id="1-首先导入alibaba的fastjson，用来解析json。当然也可以用其他的解析包"><a href="#1-首先导入alibaba的fastjson，用来解析json。当然也可以用其他的解析包" class="headerlink" title="1.首先导入alibaba的fastjson，用来解析json。当然也可以用其他的解析包"></a>1.首先导入alibaba的fastjson，用来解析json。当然也可以用其他的解析包</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.58&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-创建两个工具类方法，用来判断传入的是不是json对象或json数组"><a href="#2-创建两个工具类方法，用来判断传入的是不是json对象或json数组" class="headerlink" title="2.创建两个工具类方法，用来判断传入的是不是json对象或json数组"></a>2.创建两个工具类方法，用来判断传入的是不是json对象或json数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isJSONObj</span><span class="params">(Object json)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> json <span class="keyword">instanceof</span> JSONObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isJSONArray</span><span class="params">(Object json)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> json <span class="keyword">instanceof</span> JSONArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>java中的instanceof也称为类型比较运算符，因为它将实例与类型进行比较。它返回true或false。</p></blockquote><h2 id="3-建立核心重载方法"><a href="#3-建立核心重载方法" class="headerlink" title="3.建立核心重载方法"></a>3.建立核心重载方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getJSONValue</span><span class="params">(JSONObject json,String k,List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object j:json.keySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(isJSONObj(json.get(j)))&#123;</span><br><span class="line">            <span class="comment">//是对象</span></span><br><span class="line">            JSONObject j2= JSON.parseObject(json.get(j).toString());</span><br><span class="line">            getJSONValue(j2,k,list);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isJSONArray(json.get(j)))&#123;</span><br><span class="line">            JSONArray j3=JSON.parseArray(json.get(j).toString());</span><br><span class="line">            <span class="comment">//是数组</span></span><br><span class="line">            getJSONValue(j3,k,list);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==k)&#123;</span><br><span class="line">            <span class="comment">//是字符串</span></span><br><span class="line">            list.add(json.get(j).toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getJSONValue</span><span class="params">(JSONArray json,String k,List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object j:json)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isJSONObj(j))&#123;</span><br><span class="line">            <span class="comment">//是对象</span></span><br><span class="line">            JSONObject j2= JSON.parseObject(j.toString());</span><br><span class="line">            getJSONValue(j2,k,list);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isJSONArray(j))&#123;</span><br><span class="line">            <span class="comment">//是数组</span></span><br><span class="line">            JSONArray j3=JSON.parseArray(j.toString());</span><br><span class="line">            getJSONValue(j3,k,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-接下来写一个比较复杂的json，里面有对象嵌套数组的，数组嵌套对象的，数组嵌套数组的"><a href="#4-接下来写一个比较复杂的json，里面有对象嵌套数组的，数组嵌套对象的，数组嵌套数组的" class="headerlink" title="4.接下来写一个比较复杂的json，里面有对象嵌套数组的，数组嵌套对象的，数组嵌套数组的"></a>4.接下来写一个比较复杂的json，里面有对象嵌套数组的，数组嵌套对象的，数组嵌套数组的</h2><p><a href="http://cdn.mjava.top/blog/demojson.txt" rel="noopener" target="_blank">示例json</a></p><h2 id="5-调用方法"><a href="#5-调用方法" class="headerlink" title="5.调用方法"></a>5.调用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File file=<span class="keyword">new</span> File(demo1.class.getResource(<span class="string">"/2.json"</span>).getPath());</span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    InputStreamReader inputStreamReader=<span class="keyword">new</span> InputStreamReader(fileInputStream);</span><br><span class="line">    BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">    String line=<span class="string">""</span>;</span><br><span class="line">    StringBuffer json=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> ((line=bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        json.append(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JSONObject j3=JSON.parseObject(json.toString());</span><br><span class="line">    List&lt;String&gt; mid=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getJSONValue(j3,<span class="string">"interfaceId"</span>,mid);</span><br><span class="line">    System.out.println(mid.toString());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-成功获取"><a href="#6-成功获取" class="headerlink" title="6.成功获取"></a>6.成功获取</h2><p><img src="http://cdn.mjava.top/blog/json2.png" alt="控制台返回"></p><blockquote><p>demo源码地址：<a href="https://github.com/z573419235/studyDemo" rel="noopener" target="_blank">https://github.com/z573419235/studyDemo</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Recursive </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64影响泰文字段取值问题</title>
      <link href="/java/problem-java-base64/"/>
      <url>/java/problem-java-base64/</url>
      
        <content type="html"><![CDATA[<h2 id="今天在工作中，图片要用base64上传，上传数据中还有泰文，然后和前端app联调时发现他们传的泰文这边竟然没存到库里，怀疑是app没有传值过来，于是一番操作"><a href="#今天在工作中，图片要用base64上传，上传数据中还有泰文，然后和前端app联调时发现他们传的泰文这边竟然没存到库里，怀疑是app没有传值过来，于是一番操作" class="headerlink" title="今天在工作中，图片要用base64上传，上传数据中还有泰文，然后和前端app联调时发现他们传的泰文这边竟然没存到库里，怀疑是app没有传值过来，于是一番操作"></a>今天在工作中，图片要用base64上传，上传数据中还有泰文，然后和前端app联调时发现他们传的泰文这边竟然没存到库里，怀疑是app没有传值过来，于是一番操作</h2><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><blockquote><p>what,日志里面竟然有他们传过来的泰文的值</p></blockquote><h4 id="对比ios和android的数据"><a href="#对比ios和android的数据" class="headerlink" title="对比ios和android的数据"></a>对比ios和android的数据</h4><blockquote><p>发现日志里的数据都是一样的，但是android上传的数据全部传入了mysql数据库，ios的除了泰文，其他的也都传到了库里</p></blockquote><a id="more"></a><h4 id="确定问题"><a href="#确定问题" class="headerlink" title="确定问题"></a>确定问题</h4><blockquote><p>最后对比发现，android的泰文字段三放在base64字段前面的然后传上来的，ios是放在base64字段后面传上来的，怀疑问题在此处</p></blockquote><h4 id="修复bug"><a href="#修复bug" class="headerlink" title="修复bug"></a>修复bug</h4><blockquote><p>于是叫ios也和android一样，把上传字段的顺序调整了以下，把泰文的字段放在base64字段前面，然后上传。改了之后试了以下，，竟然解决了，2222333333</p></blockquote><p>总结：暂时不知道具体什么原因，有可能是因为base64数据太长了，影响到泰文的字段存储了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Base64 </tag>
            
            <tag> Pit </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
