<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灰色Code</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mjava.top/"/>
  <updated>2021-01-26T07:59:12.388Z</updated>
  <id>https://mjava.top/</id>
  
  <author>
    <name>H&amp;K</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用GitHub Actions编译树莓派内核</title>
    <link href="https://mjava.top/linux/github-actions-build-pi-kernerl/"/>
    <id>https://mjava.top/linux/github-actions-build-pi-kernerl/</id>
    <published>2021-01-26T07:56:07.000Z</published>
    <updated>2021-01-26T07:59:12.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h2><p>仓库地址：<a href="https://github.com/GreyCode9/make-raspberrypi-kernel" rel="noopener" target="_blank">https://github.com/GreyCode9/make-raspberrypi-kernel</a></p><h2 id="创建秘钥"><a href="#创建秘钥" class="headerlink" title="创建秘钥"></a>创建秘钥</h2><ol><li><p>点击Github右上角头像 -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token</p></li><li><p>或者直接点这个链接进入： <a href="https://github.com/settings/tokens" rel="noopener" target="_blank">https://github.com/settings/tokens</a></p><p><img src="http://cdn.mjava.top/20210126150521.png" alt="20210126150521"></p></li></ol><a id="more"></a><p><img src="http://cdn.mjava.top/20210126150712.png" alt="20210126150712"></p><p><font color="red">创建后保存这个秘钥(秘钥只显示一次)</font></p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>创建仓库<strong><a href="https://github.com/GreyCode9/make-raspberrypi-kernel" rel="noopener" target="_blank">make-raspberrypi-kernel</a></strong></p><p>然后点击仓库的Settings -&gt; Secrets -&gt;New repository secret</p><p><strong>然后填入刚才生成的秘钥</strong></p><p><img src="http://cdn.mjava.top/20210126151157.png" alt="20210126151157"></p><h2 id="创建Actions"><a href="#创建Actions" class="headerlink" title="创建Actions"></a>创建Actions</h2><p>接着点击<strong>Actions</strong> ,创建一个Actions，然后填入如下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Make</span> <span class="string">RaspberryPi</span> <span class="string">Kernel</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">  push:</span></span><br><span class="line"><span class="attr">    tags:</span> </span><br><span class="line"><span class="bullet">      -</span> <span class="string">'v*'</span> <span class="comment"># 当推送的Tag为v开头的，就会触发构建</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  USE_SSH_CONFIG:</span> <span class="literal">true</span> <span class="comment"># 是否使用ssh连接进行 true:使用 false:不使用</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-18.04</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">      - uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">pull</span> <span class="string">RaspberryPi</span> <span class="string">Kernel</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd ../</span></span><br><span class="line"><span class="string">          git clone https://github.com/raspberrypi/linux.git</span></span><br><span class="line"><span class="string"></span><span class="attr">      - name:</span> <span class="string">pull</span> <span class="string">RaspberryPi</span> <span class="string">Kernel</span> <span class="string">Tool</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd ../</span></span><br><span class="line"><span class="string">          git clone https://github.com/raspberrypi/tools.git</span></span><br><span class="line"><span class="string"></span><span class="attr">      - name:</span> <span class="string">Move</span> <span class="string">.config</span></span><br><span class="line"><span class="attr">        if:</span> <span class="string">env.USE_SSH_CONFIG</span> <span class="string">==</span> <span class="string">'false'</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cp .config ../linux</span></span><br><span class="line"><span class="string"></span><span class="attr">      - name:</span> <span class="string">Setup</span> <span class="string">Debug</span> <span class="string">Session</span> <span class="comment"># 用SSH连接Actions</span></span><br><span class="line"><span class="attr">        if:</span> <span class="string">env.USE_SSH_CONFIG</span> <span class="string">==</span> <span class="string">'true'</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">csexton/debugger-action@master</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Make</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd ../</span></span><br><span class="line"><span class="string">          export WORKPATH=$(pwd)</span></span><br><span class="line"><span class="string">          export PATH=$PATH:$WORKPATH/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span></span><br><span class="line"><span class="string">          export PATH=$PATH:$WORKPATH/tools/arm-bcm2708/arm-bcm2708-linux-gnueabi/bin</span></span><br><span class="line"><span class="string">          cd linux/</span></span><br><span class="line"><span class="string">          make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j8</span></span><br><span class="line"><span class="string"></span><span class="attr">      - name:</span> <span class="string">Create</span> <span class="string">Release</span></span><br><span class="line"><span class="attr">        id:</span> <span class="string">create_release</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">actions/create-release@master</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">          GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.TOKEN</span> <span class="string">&#125;&#125;</span> <span class="comment"># 之前GitHub添加的Token</span></span><br><span class="line"><span class="attr">        with:</span></span><br><span class="line"><span class="attr">          tag_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">&#125;&#125;</span> <span class="comment"># (tag)标签名称</span></span><br><span class="line"><span class="attr">          release_name:</span> <span class="string">Release</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">          draft:</span> <span class="literal">false</span> <span class="comment"># 是否是草稿</span></span><br><span class="line"><span class="attr">          prerelease:</span> <span class="literal">false</span> <span class="comment"># 是否是预发布</span></span><br><span class="line">      <span class="comment"># 上传构建结果到 Release（把打包的tgz上传到Release）</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">build</span> <span class="string">TAR</span> <span class="string">PACKAGE</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          tar -czvf raspberrypi-kernel.tar.gz ../linux/arch/arm/boot</span></span><br><span class="line"><span class="string"></span><span class="attr">      - name:</span> <span class="string">Upload</span> <span class="string">Release</span> <span class="string">Asset</span></span><br><span class="line"><span class="attr">        id:</span> <span class="string">upload-release-asset</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">actions/upload-release-asset@master</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">          GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">        with:</span></span><br><span class="line"><span class="attr">          upload_url:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.create_release.outputs.upload_url</span> <span class="string">&#125;&#125;</span> <span class="comment"># 上传地址，通过创建Release获取到的</span></span><br><span class="line"><span class="attr">          asset_path:</span> <span class="string">./raspberrypi-kernel.tar.gz</span> <span class="comment"># 要上传文件</span></span><br><span class="line"><span class="attr">          asset_name:</span> <span class="string">raspberrypi-kernel.tar.gz</span> <span class="comment"># 上传后的文件名</span></span><br><span class="line"><span class="attr">          asset_content_type:</span> <span class="string">application/gzip</span></span><br></pre></td></tr></table></figure><ul><li>可以在本地配置好<code>.config</code>文件然后上传到仓库，然后把Actions的配置文件中的<code>USE_SSH_CONFIG</code>字段改成<code>false</code>。</li><li>也可以直接在<code>Actions</code>中进行配置<code>.config</code>文件，需要把<code>USE_SSH_CONFIG</code>字段改成<code>true</code>。</li></ul><h2 id="触发构建"><a href="#触发构建" class="headerlink" title="触发构建"></a>触发构建</h2><p>当上面完成后，就可以把代码pull到本地，然后根据自己的需求配置<code>.config</code>文件。执行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a v1.0 -m 'build kernel'</span><br><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure><p>推送完成后，就可以看到Actions正在构建了</p><p><img src="http://cdn.mjava.top/20210126152258.png" alt="20210126152258"></p><p>构建完成后，就可以在<code>Release</code>下载构建好的内核文件了</p><p><img src="http://cdn.mjava.top/20210126152413.png" alt="20210126152413"></p><p><img src="http://cdn.mjava.top/20210126152428.png" alt="20210126152413"></p><h2 id="资料索引"><a href="#资料索引" class="headerlink" title="资料索引"></a>资料索引</h2><ul><li><a href="https://www.cnblogs.com/YAN-HUA/p/13530906.html" rel="noopener" target="_blank">https://www.cnblogs.com/YAN-HUA/p/13530906.html</a></li><li><a href="http://doc.openluat.com/article/166/0" rel="noopener" target="_blank">http://doc.openluat.com/article/166/0</a></li><li><a href="https://www.daimajiaoliu.com/daima/4793af6f2900402" rel="noopener" target="_blank">https://www.daimajiaoliu.com/daima/4793af6f2900402</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;仓库地址&quot;&gt;&lt;a href=&quot;#仓库地址&quot; class=&quot;headerlink&quot; title=&quot;仓库地址&quot;&gt;&lt;/a&gt;仓库地址&lt;/h2&gt;&lt;p&gt;仓库地址：&lt;a href=&quot;https://github.com/GreyCode9/make-raspberrypi-kernel&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/GreyCode9/make-raspberrypi-kernel&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;创建秘钥&quot;&gt;&lt;a href=&quot;#创建秘钥&quot; class=&quot;headerlink&quot; title=&quot;创建秘钥&quot;&gt;&lt;/a&gt;创建秘钥&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;点击Github右上角头像 -&amp;gt; Settings -&amp;gt; Developer settings -&amp;gt; Personal access tokens -&amp;gt; Generate new token&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或者直接点这个链接进入： &lt;a href=&quot;https://github.com/settings/tokens&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/settings/tokens&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/20210126150521.png&quot; alt=&quot;20210126150521&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://mjava.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://mjava.top/tags/Linux/"/>
    
      <category term="Github Actions" scheme="https://mjava.top/tags/Github-Actions/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://mjava.top/recommend/git-commend-note/"/>
    <id>https://mjava.top/recommend/git-commend-note/</id>
    <published>2020-09-16T07:16:56.000Z</published>
    <updated>2020-09-16T07:17:23.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git 是用于 Linux<a href="https://baike.baidu.com/item/内核" rel="noopener" target="_blank">内核</a>开发的<a href="https://baike.baidu.com/item/版本控制" rel="noopener" target="_blank">版本控制</a>工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使<a href="https://baike.baidu.com/item/源代码" rel="noopener" target="_blank">源代码</a>的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。</p><a id="more"></a><p>git对于很多人来说,真的是又爱又恨,用的好可以提示开发效率;用不好,解决各种冲突就要累的你半死</p><h2 id="git结构"><a href="#git结构" class="headerlink" title="git结构"></a>git结构</h2><blockquote><p>网上有 我就不画了</p></blockquote><p><img src="http://cdn.mjava.top/blog/20200605001853.png" alt="git结构图"></p><ul><li><p>workspace    相当于就是我们的本地电脑上的文件</p></li><li><p>Index    缓存区</p></li><li><p>Repository    本地仓库</p></li><li><p>Remote    远程仓库(github/gitlab/gitee)</p></li></ul><h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><p>git官方提供的命令多达几百个,可是我们日常却用不到这么多</p><p>所以我就整理了一下日常使用的命令</p><p>现在关注微信公招:<code>灰色Code</code></p><p>回复关键字:<code>git</code></p><p>就可以获取思维导图高清图片及导图源地址</p><p><img src="http://cdn.mjava.top/blog/20200605002904.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h2&gt;&lt;p&gt;Git 是用于 Linux&lt;a href=&quot;https://baike.baidu.com/item/内核&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;内核&lt;/a&gt;开发的&lt;a href=&quot;https://baike.baidu.com/item/版本控制&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;版本控制&lt;/a&gt;工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使&lt;a href=&quot;https://baike.baidu.com/item/源代码&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;源代码&lt;/a&gt;的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mjava.top/categories/Java/"/>
    
    
      <category term="Git" scheme="https://mjava.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Fegin和RestTemplate添加全局请求头</title>
    <link href="https://mjava.top/spring/fegin-resttemplate-addheard/"/>
    <id>https://mjava.top/spring/fegin-resttemplate-addheard/</id>
    <published>2020-09-16T07:14:43.000Z</published>
    <updated>2020-09-16T07:16:16.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fegin添加全局请求头"><a href="#Fegin添加全局请求头" class="headerlink" title="Fegin添加全局请求头"></a>Fegin添加全局请求头</h2><ul><li>实现RequestInterceptor接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现RequestInterceptor接口的apply方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>&#123;</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder</span><br><span class="line">                .getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line">        <span class="keyword">if</span> (headerNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">                String name = headerNames.nextElement();</span><br><span class="line">                String values = request.getHeader(name);</span><br><span class="line">                requestTemplate.header(name, values);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p>在<code>@FeginClient</code>注释里<code>configuration</code>所填入的类文件中添加上面的拦截器</p><blockquote><p>比如 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">// configuration指定的类为FeignConfig</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">@FeignClient</span>(name = <span class="string">"$&#123;TinyConfigServiceName&#125;"</span>,path=<span class="string">"/config"</span>,configuration = FeignConfig.class)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>在FeignConfig类中添加拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FeignRequestInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="RestTemplate添加全局请求头"><a href="#RestTemplate添加全局请求头" class="headerlink" title="RestTemplate添加全局请求头"></a>RestTemplate添加全局请求头</h2><ul><li><p>编写拦截器,实现<code>ClientHttpRequestInterceptor</code>接口的<code>intercept</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(HttpRequest httpRequest, <span class="keyword">byte</span>[] bytes, ClientHttpRequestExecution clientHttpRequestExecution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpHeaders httpHeaders=httpRequest.getHeaders();</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder</span><br><span class="line">                .getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line">        <span class="keyword">if</span> (headerNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">                String name = headerNames.nextElement();</span><br><span class="line">                String values = request.getHeader(name);</span><br><span class="line">                httpHeaders.add(name, values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clientHttpRequestExecution.execute(httpRequest,bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在springboot的启动类里添加<code>RestTemplate</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ioc添加RestTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyInterceptor myInterceptor=<span class="keyword">new</span> MyInterceptor();</span><br><span class="line">        RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">        restTemplate.setInterceptors(Collections.singletonList(myInterceptor));</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Fegin添加全局请求头&quot;&gt;&lt;a href=&quot;#Fegin添加全局请求头&quot; class=&quot;headerlink&quot; title=&quot;Fegin添加全局请求头&quot;&gt;&lt;/a&gt;Fegin添加全局请求头&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实现RequestInterceptor接口&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* 实现RequestInterceptor接口的apply方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FeignRequestInterceptor&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RequestInterceptor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(RequestTemplate requestTemplate)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .getRequestAttributes();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        HttpServletRequest request = attributes.getRequest();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (headerNames != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (headerNames.hasMoreElements()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                String name = headerNames.nextElement();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                String values = request.getHeader(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                requestTemplate.header(name, values);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://mjava.top/categories/Spring/"/>
    
    
      <category term="Fegin" scheme="https://mjava.top/tags/Fegin/"/>
    
      <category term="Resttemplate" scheme="https://mjava.top/tags/Resttemplate/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MDC</title>
    <link href="https://mjava.top/java/mdc-test/"/>
    <id>https://mjava.top/java/mdc-test/</id>
    <published>2020-09-16T07:10:47.000Z</published>
    <updated>2020-09-16T07:11:33.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MDC是什么？"><a href="#MDC是什么？" class="headerlink" title="MDC是什么？"></a>MDC是什么？</h2><p><code>MDC</code> 全拼 <code>Mapped Diagnostic Contexts</code>，是<code>SLF4J</code>类日志系统中实现分布式多线程日志数据传递的重要工具；可利用<code>MDC</code>将一些运行时的上下文数据打印出来。目前只有<code>log4j</code>和<code>logback</code>提供原生的<code>MDC</code>支持；</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><code>MDC</code>里面提供的都是静态方法，所以可以直接调用</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一个key</span></span><br><span class="line">MDC.put(<span class="string">"name"</span>,<span class="string">"灰色Code"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个key的值</span></span><br><span class="line">MDC.get(<span class="string">"name"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 删除一个key</span></span><br><span class="line">MDC.remove(<span class="string">"name"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 清空MDC里的内容</span></span><br><span class="line">MDC.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取上下文中的map</span></span><br><span class="line">Map&lt;String,String&gt; map = MDC.getCopyOfContextMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置MDC的map</span></span><br><span class="line">MDC.setContextMap(map);</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h3><p>通过阅读<code>MDC</code>的源码可以发现，它其实是调用了<code>MDCAdapter</code>的接口来实现的</p><p><img src="http://cdn.mjava.top/blog/20200729200214.png" alt></p><h3 id="MDCAdapter"><a href="#MDCAdapter" class="headerlink" title="MDCAdapter"></a>MDCAdapter</h3><p><code>MDCAdapter</code>接口有三个实现类，而<code>MDC</code>是调用了<code>LogbackMDCAdapter</code>里的方法(在MDC里有一个静态代码块，实例化了这个对象)</p><p><img src="http://cdn.mjava.top/blog/20200729201118.png" alt></p><h3 id="LogbackMDCAdapter"><a href="#LogbackMDCAdapter" class="headerlink" title="LogbackMDCAdapter"></a>LogbackMDCAdapter</h3><p><strong>而</strong><code>LogbackMDCAdapter</code>主要是用<code>ThreadLocal</code>在线程上下文中维护一个<code>HashMap</code>来实现的</p><p><img src="http://cdn.mjava.top/blog/20200729201650.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么样,实现原理是不是很简单，就这么短短几行代码，就实现了听起来很高大上的<code>MDC</code>。</p><p>所以简单来说，<code>MDC</code>就是利用<code>ThreadLocal</code>在线程中维护了一个<code>HashMap</code>，利用<code>HashMap</code>来存放数据</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MDC是什么？&quot;&gt;&lt;a href=&quot;#MDC是什么？&quot; class=&quot;headerlink&quot; title=&quot;MDC是什么？&quot;&gt;&lt;/a&gt;MDC是什么？&lt;/h2&gt;&lt;p&gt;&lt;code&gt;MDC&lt;/code&gt; 全拼 &lt;code&gt;Mapped Diagnostic Contexts&lt;/code&gt;，是&lt;code&gt;SLF4J&lt;/code&gt;类日志系统中实现分布式多线程日志数据传递的重要工具；可利用&lt;code&gt;MDC&lt;/code&gt;将一些运行时的上下文数据打印出来。目前只有&lt;code&gt;log4j&lt;/code&gt;和&lt;code&gt;logback&lt;/code&gt;提供原生的&lt;code&gt;MDC&lt;/code&gt;支持；&lt;/p&gt;&lt;h2 id=&quot;简单使用&quot;&gt;&lt;a href=&quot;#简单使用&quot; class=&quot;headerlink&quot; title=&quot;简单使用&quot;&gt;&lt;/a&gt;简单使用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;MDC&lt;/code&gt;里面提供的都是静态方法，所以可以直接调用&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mjava.top/categories/Java/"/>
    
    
      <category term="Logback" scheme="https://mjava.top/tags/Logback/"/>
    
      <category term="MDC" scheme="https://mjava.top/tags/MDC/"/>
    
  </entry>
  
  <entry>
    <title>JDKproxy和Cglib初探</title>
    <link href="https://mjava.top/java/jdkproxy-cglib/"/>
    <id>https://mjava.top/java/jdkproxy-cglib/</id>
    <published>2020-09-16T07:09:47.000Z</published>
    <updated>2020-09-16T07:10:26.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDKproxy和Cglib初探"><a href="#JDKproxy和Cglib初探" class="headerlink" title="JDKproxy和Cglib初探"></a>JDKproxy和Cglib初探</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Java中，动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地制定一组接口及委托类对象，便能动态地获得代理类。动态代理在Java中有着广泛的应用，比如Spring AOP，Hibernate数据查询、测试框架的后端mock、RPC，Java注解对象获取等。</p><a id="more"></a><h2 id="JDK原生动态代理-JDKProxy"><a href="#JDK原生动态代理-JDKProxy" class="headerlink" title="JDK原生动态代理(JDKProxy)"></a>JDK原生动态代理(JDKProxy)</h2><p><code>JDKProxy</code>只能对<code>实现了接口的类</code>生成代理，而不能针对<code>普通类</code> 。<code>JDKProxy</code>原生的<code>反射API</code>进行操作，在生成类上比较高效。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="http://cdn.mjava.top/blog/20200729000830.png" rel="noopener" target="_blank"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> <span class="keyword">implements</span> <span class="title">TestInterface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"JDK动态代理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestClass testClass=<span class="keyword">new</span> TestClass();</span><br><span class="line">        ProxyHandle proxyHandle=<span class="keyword">new</span> ProxyHandle(testClass);</span><br><span class="line">        <span class="comment">//使用接口</span></span><br><span class="line">        TestInterface testClass1= (TestInterface) Proxy.newProxyInstance(</span><br><span class="line">                testClass.getClass().getClassLoader(),</span><br><span class="line">                testClass.getClass().getInterfaces(),proxyHandle);</span><br><span class="line">        testClass1.test();</span><br><span class="line">        System.out.println(<span class="string">"代理类名称："</span>+testClass1.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandle</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object originaObj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandle</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.originaObj=o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置"</span>);</span><br><span class="line">        Object object=method.invoke(originaObj,args);</span><br><span class="line">        System.out.println(<span class="string">"后置"</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">前置</span><br><span class="line">    JDK动态代理</span><br><span class="line">    后置</span><br><span class="line">    代理类名称：class com.example.demo.aop.$Proxy0</span><br></pre></td></tr></table></figure><h2 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h2><p><code>Cglib</code>代理是针对<code>所有类</code>（包括实现接口的类和普通的类）实现代理，主要是对指定的类<strong>生成一个子类</strong>，覆盖其中的方法(<strong>所以该类或方法不能声明称final的</strong>) 。<code>Cglib</code>使用<code>ASM框架</code>直接对字节码进行操作，在类的执行过程中比较高效</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><a href="http://cdn.mjava.top/blog/20200729001250.png" rel="noopener" target="_blank"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterClass</span> <span class="keyword">implements</span> <span class="title">InterTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口测试方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 普通类</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(CG.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object[] objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"前置"</span>);</span><br><span class="line">                Object object=methodProxy.invokeSuper(o,objects);</span><br><span class="line">                System.out.println(<span class="string">"后置"</span>);</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        CG cglibTest= (CG) enhancer.create();</span><br><span class="line">        cglibTest.test();</span><br><span class="line">        System.out.println(<span class="string">"代理类名称1："</span>+cglibTest.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 实现了接口的类</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Enhancer enhancer2=<span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer2.setSuperclass(InterClass.class);</span><br><span class="line">        enhancer2.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object[] objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接口类前置"</span>);</span><br><span class="line">                Object object=methodProxy.invokeSuper(o,objects);</span><br><span class="line">                System.out.println(<span class="string">"接口类后置"</span>);</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        InterClass interClass= (InterClass) enhancer2.create();</span><br><span class="line">        interClass.t1();</span><br><span class="line">        System.out.println(<span class="string">"代理类名称2："</span>+interClass.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CG</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理类测试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">前置</span><br><span class="line">    代理类测试</span><br><span class="line">    后置</span><br><span class="line">    代理类名称1：class com.example.demo.aop.CG$$EnhancerByCGLIB$$5c6cbf31</span><br><span class="line">    </span><br><span class="line">    接口类前置</span><br><span class="line">    我是接口测试方法</span><br><span class="line">    接口类后置</span><br><span class="line">    代理类名称2：class com.example.demo.aop.InterClass$$EnhancerByCGLIB$$80c75859</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDKproxy和Cglib初探&quot;&gt;&lt;a href=&quot;#JDKproxy和Cglib初探&quot; class=&quot;headerlink&quot; title=&quot;JDKproxy和Cglib初探&quot;&gt;&lt;/a&gt;JDKproxy和Cglib初探&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在Java中，动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地制定一组接口及委托类对象，便能动态地获得代理类。动态代理在Java中有着广泛的应用，比如Spring AOP，Hibernate数据查询、测试框架的后端mock、RPC，Java注解对象获取等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mjava.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://mjava.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java包装类缓存机制</title>
    <link href="https://mjava.top/java/java-base-data-pack/"/>
    <id>https://mjava.top/java/java-base-data-pack/</id>
    <published>2020-09-16T07:08:18.000Z</published>
    <updated>2020-09-16T07:09:58.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>首先,来看一道常见的面试题,下面代码运行后会输出什么?</p><p><img src="http://cdn.mjava.top/blog/20200603110911.png" alt></p><p>上面代码运行后,最终会输出<code>false</code>和<code>true</code>;为什么会这样呢?</p><p>按道理来说,在Java中<code>==</code>是比较两个对象的地址,上面代码中<code>i3</code>和<code>i4</code>是两个不同的对象,理应也应该返回是<code>false</code>,怎么返回是<code>true</code>呢?让我们慢慢往下看</p><h2 id="Integer的缓存机制"><a href="#Integer的缓存机制" class="headerlink" title="Integer的缓存机制"></a>Integer的缓存机制</h2><a id="more"></a><p>让我们来看看他的源代码.</p><p>当执行<code>Integer i=128;</code>这个语句时,Java会调用<code>valueOf(int i)</code>方法,然后<code>自动装箱</code>的方式,让其变成<code>Integer i=new Integer(128)</code>,具体源码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">//装箱</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码中可以看到,在装箱之前会执行一个<code>if</code>语句,这个<code>if</code>语句就是判断传入的值是否在缓存内,如果在缓存内,就直接返回缓存内的值,如果不在缓存内,就装箱,在堆内创建一个新空间来存放.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer包装类缓存源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到,<code>Integer</code>的缓存范围是<code>-128~127</code>,所以过程大致如下:</p><p><img src="http://cdn.mjava.top/blog/20200603114246.png" alt></p><p>按照上面这个方法,只要在数据在缓存池范围内的,都会引用缓存在堆内的地址,所有上面的<code>i3==i4</code>会输出为<code>true</code>;而不在缓存范围内的,就会在堆中开放新的空间来存放对象,所以地址不同,用<code>==</code>比较返回也不同;</p><h2 id="其他包装类缓存机制"><a href="#其他包装类缓存机制" class="headerlink" title="其他包装类缓存机制"></a>其他包装类缓存机制</h2><p>除了<code>Integer</code>之外,其他的包装类也使用了缓存技术;</p><h3 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h3><blockquote><p>缓存范围-128~127</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h3><blockquote><p>缓存范围-128<del>127   (byte范围:一个byte占8位,所以取值范围是**-2^7</del>2^7-1**)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ByteCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Byte cache[] = <span class="keyword">new</span> Byte[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Byte((<span class="keyword">byte</span>)(i - <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><blockquote><p>缓存范围0~127  (ascii码范围) </p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Short"><a href="#Short" class="headerlink" title="Short"></a>Short</h3><blockquote><p>缓存范围-128~127</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ShortCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><blockquote><p>缓存范围 <code>true</code>  <code>false</code>     它只设置了两个静态变量用来充当缓存</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>包装类对比数据是否相同的时候,建议采用重写的<code>equals()</code>方法.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;首先,来看一道常见的面试题,下面代码运行后会输出什么?&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/blog/20200603110911.png&quot; alt&gt;&lt;/p&gt;&lt;p&gt;上面代码运行后,最终会输出&lt;code&gt;false&lt;/code&gt;和&lt;code&gt;true&lt;/code&gt;;为什么会这样呢?&lt;/p&gt;&lt;p&gt;按道理来说,在Java中&lt;code&gt;==&lt;/code&gt;是比较两个对象的地址,上面代码中&lt;code&gt;i3&lt;/code&gt;和&lt;code&gt;i4&lt;/code&gt;是两个不同的对象,理应也应该返回是&lt;code&gt;false&lt;/code&gt;,怎么返回是&lt;code&gt;true&lt;/code&gt;呢?让我们慢慢往下看&lt;/p&gt;&lt;h2 id=&quot;Integer的缓存机制&quot;&gt;&lt;a href=&quot;#Integer的缓存机制&quot; class=&quot;headerlink&quot; title=&quot;Integer的缓存机制&quot;&gt;&lt;/a&gt;Integer的缓存机制&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mjava.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://mjava.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时栈帧</title>
    <link href="https://mjava.top/java/jvm/java-jvm-stack-1/"/>
    <id>https://mjava.top/java/jvm/java-jvm-stack-1/</id>
    <published>2020-09-16T07:06:15.000Z</published>
    <updated>2020-09-16T07:06:47.327Z</updated>
    
    <content type="html"><![CDATA[<p>在JVM中，每个线程都包含n个栈帧，每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p><p>栈帧的生命周期<strong>随着方法的创建而创建，随着方法的结束而销毁，无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算方法的结束。</strong></p><p>在某条线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧称为<strong>当前栈帧</strong>，这个栈帧对应的方法称为<strong>当前方法</strong>，定义这个方法的类称为<strong>当前类</strong>。<strong>对局部变量表和操作数栈的各种操作，通常都指的是对当前栈帧的局部变量表和操作数栈所进行的操作。</strong></p><a id="more"></a><blockquote><p><strong>注意:</strong>栈帧是线程本地私有的数据，不可能在一个栈帧 之中引用另外一个线程的栈帧</p></blockquote><p><img src="http://cdn.mjava.top/blog/20200731162235.jpg" alt></p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p><code>局部变量表（Local Variables Table）</code>是一组<strong>变量值</strong>的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。</p><h3 id="存储方法"><a href="#存储方法" class="headerlink" title="存储方法"></a>存储方法</h3><p>局部变量表的容量以<code>变量槽（Variable Slot）</code>为最小单位，一般在虚拟机中，一个Slot占用<strong>32位</strong>存储空间(这不是固定的，虚拟机可以自行改变每个槽占用空间的大小,但一般都是32位)。</p><p>Java虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，索引值的范围是从<code>0</code>开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。</p><h4 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h4><p>在Java中，<code>long</code>在内存占64位，所以局部变量表<strong>用2个slot来存储</strong></p><p><img src="http://cdn.mjava.top/blog/20200730225516.png" alt></p><p>对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机<strong>不允许采用任何方式单独访问其中的某一个</strong>，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。</p><h3 id="long和double的非原子性协定"><a href="#long和double的非原子性协定" class="headerlink" title="long和double的非原子性协定"></a>long和double的非原子性协定</h3><blockquote><p>在Java内存模型中，对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：<strong>允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行</strong>，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的<strong>“long和double的非原子性协定”（Non-Atomic Treatment of doubleand long Variables）</strong>。</p></blockquote><p>虽然有这个协定，<strong>但是</strong>，由于<code>局部变量表(Local Variable Table)</code>是建立在线程堆栈中的，属于<strong>线程私有的数据</strong>，无论读写两个连续的变量槽是否为原子操作，都<strong>不会引起数据竞争和线程安全问题</strong>。</p><h3 id="初始值问题"><a href="#初始值问题" class="headerlink" title="初始值问题"></a>初始值问题</h3><p>我们已经知道<strong>类的字段变量</strong>有两次赋初始值的过程，一次在<strong>准备阶段</strong>，赋予系统初始值；另外一次在<strong>初始化阶段</strong>，赋予程序员定义的初始值。</p><p>但<strong>局部变量就不一样</strong>了，如果一个局部变量定义了但<strong>没有赋初始值</strong>，那它是<strong>完全不能使用</strong>的。所以不要认为Java中任何情况下都存在诸如整型变量默认为0、布尔型变量默认为false等这样的默认值规则。</p><h4 id="eg："><a href="#eg：" class="headerlink" title="eg："></a>eg：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法会报：</span></span><br><span class="line"><span class="comment">// Error:(12, 28) java: variable y might not have been initialized</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> z=<span class="number">3</span>;</span><br><span class="line">        System.out.println(y+z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个会正常输出 3； 因为int的初始值为0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> z=<span class="number">3</span>;</span><br><span class="line">        System.out.println(y+z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p><code>操作数栈（Operand Stack）</code>也常被称为<code>操作栈</code>，它是一个后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的<code>max_stacks</code>数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在<code>max_stacks</code>数据项中设定的最大值。</p><h3 id="eg-1"><a href="#eg-1" class="headerlink" title="eg:"></a>eg:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> y=<span class="number">9223372036854775800L</span>;</span><br><span class="line">        <span class="keyword">int</span> z=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> x=y+z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用<code>javap -verbose JVMTest</code>来查看他的<code>class</code>文件的字节码指令</p><p><img src="http://cdn.mjava.top/blog/20200730235131.png" alt></p><p><strong>在操作栈中的流程大致为：</strong></p><p><img src="http://cdn.mjava.top/blog/20200731105247.jpg" alt></p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>每个栈帧都包含一个指向当前方法所在类型的<code>运行时常量池</code>的引用，持有这个引用是为了支持<code>方法调用</code>过程中的<code>动态连接（Dynamic Linking）</code>。在<code>Class</code>文件里，一个方法若要调用其他方法，或者访问成员变量，则需要通过<code>符号引用(symolic reference)</code>来表示，<code>动态链接</code>的作用就是将这些以<code>符号引用</code>所表示的方法转换为实际方法的直接引用。</p><h3 id="什么是符号引用？"><a href="#什么是符号引用？" class="headerlink" title="什么是符号引用？"></a>什么是符号引用？</h3><p><img src="http://cdn.mjava.top/blog/20200731110742.png" alt></p><p>通过查看字节码，上面的<code>#7</code>，<code>#8</code>，<code>#9</code>等等都是符号引用，他在class文件里只是个符号，就像你定义一个变量名称一样，变量名只是和<code>字符符号</code>，并不是真正的指向内存的地址指针。这些符号都指向<code>运行时常量池</code>的引用。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>Java在调用方法时，只有两种返回方法，一种是<code>正常返回</code>，一种是<code>异常返回</code>。</p><h3 id="正常返回"><a href="#正常返回" class="headerlink" title="正常返回"></a>正常返回</h3><p>正常返回指的就是在执行方法时，中间并没有异常抛出，或者已正确处理抛出的异常，这时就称当前<code>方法正常调用完成</code>，如果有返回值，就会给他调用者返回一个值，如果没有返回值(<code>void</code>)就正常返回。</p><p>这种场景下，当前栈帧承担着恢复调用者状态的责任，<strong>包括恢复调用者的局部变量表和操作数栈，以及正确递增程序计数器，以跳过刚才执行的调用方法指令等。</strong>调用者的代码在被调用方法的返回值压入调用者栈帧的操作数栈后，会正常执行。</p><h3 id="异常返回"><a href="#异常返回" class="headerlink" title="异常返回"></a>异常返回</h3><p>在调用一些方法时，一些异常没有被正确捕获，就会导致方法终止，此时称<code>方法异常调用完成</code>，那一定不会有方法返回值返回给其调用者。</p><p>无论采用何种退出方式，在方法退出之后，都<strong>必须返回到最初方法被调用时的位置</strong>，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。</p><p>怎么理解这个<strong>必须返回到最初方法被调用时的位置</strong>呢？</p><p>eg:</p><p><img src="http://cdn.mjava.top/blog/20200731164803.png" alt></p><p>上面异常是在<code>13行</code>发生的，但是它并没有停在<code>13行</code>，而是回到了最初调用它<code>第10行</code>的位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JVM中，每个线程都包含n个栈帧，每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。&lt;/p&gt;&lt;p&gt;栈帧的生命周期&lt;strong&gt;随着方法的创建而创建，随着方法的结束而销毁，无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算方法的结束。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在某条线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧称为&lt;strong&gt;当前栈帧&lt;/strong&gt;，这个栈帧对应的方法称为&lt;strong&gt;当前方法&lt;/strong&gt;，定义这个方法的类称为&lt;strong&gt;当前类&lt;/strong&gt;。&lt;strong&gt;对局部变量表和操作数栈的各种操作，通常都指的是对当前栈帧的局部变量表和操作数栈所进行的操作。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://mjava.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载过程</title>
    <link href="https://mjava.top/java/jvm/java-class-load-2/"/>
    <id>https://mjava.top/java/jvm/java-class-load-2/</id>
    <published>2020-09-16T07:04:22.000Z</published>
    <updated>2020-09-16T07:05:00.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol><li><p>通过一个类的全限定名(例如：<code>java.lang.String</code>)来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</p></li></ol><blockquote><p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。</p></blockquote><a id="more"></a><ul><li><p>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</p></li><li><p>从网络中获取，这种场景最典型的应用就是Web Applet。</p></li><li><p>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</p></li><li><p>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</p></li><li><p>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</p></li><li><p>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</p></li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li>文件格式验证<ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li><li>·Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li><li>……</li></ul></li><li>元数据验证<ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li><li>……</li></ul></li><li>字节码验证<ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li><li>……</li></ul></li><li>符号引用验证<ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当前类访问。</package></li><li>……</li></ul></li><li></li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段</p><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量value在准备阶段过后的初始值为0而不是123</span></span><br><span class="line"><span class="comment">// 因为这时尚未开始执行任何Java方法 value赋值为123的动作要到类的初始化阶段才会被执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.mjava.top/blog/20200726220517.jpeg" alt></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是Java虚拟机将常量池内的<code>符号引用</code>替换为<code>直接引用</code>的过程</p><ul><li><p><strong>符号引用（Symbolic References）</strong>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p><blockquote><p>下面红框中的都属于符号引用</p></blockquote><p><img src="http://cdn.mjava.top/blog/20200726220833.png" alt></p></li><li><p><strong>直接引用（Direct References）</strong>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p></li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTc4NDUyOA==&tempkey=MTA3MV9NS1dJTVFnVDhRQkRid2hBSDB4aUE2X3Nham5Lcm9VMlpXVlIzTGd4dkk0eDNNb29iV3NlaGh0blA3Z25CcmJ6cXBLYzl5Z09zakZSakNTeFdTOUtkbUQzZnNST0pnUUNTOEhkb1J3Ul84MDhPaEw1bGZSVm9TdXNteG5DLUowSDdmUGxYajkxSWFETENkZ0h0NTY1UkJfOC0yV0laXzdyakNfVDdnfn4%3D&chksm=03a1657734d6ec6126a1c6a802506964f632a2dff53f123de74de0f865b83ef11a9b338a187d#rd" rel="noopener" target="_blank">jvm类初始化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加载&quot;&gt;&lt;a href=&quot;#加载&quot; class=&quot;headerlink&quot; title=&quot;加载&quot;&gt;&lt;/a&gt;加载&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过一个类的全限定名(例如：&lt;code&gt;java.lang.String&lt;/code&gt;)来获取定义此类的二进制字节流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在内存中生成一个代表这个类的&lt;code&gt;java.lang.Class&lt;/code&gt;对象，作为方法区这个类的各种数据的访问入口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://mjava.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM中的双亲委派机制</title>
    <link href="https://mjava.top/java/jvm/java-class-load-1/"/>
    <id>https://mjava.top/java/jvm/java-class-load-1/</id>
    <published>2020-09-16T07:02:34.000Z</published>
    <updated>2020-09-16T07:03:33.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四种类加载器"><a href="#四种类加载器" class="headerlink" title="四种类加载器"></a>四种类加载器</h2><ul><li>启动类加载器(Bootstrap Class Loader )：加载<code>$JAVA_HOME/jre/lib</code>目录下的jar包</li><li>拓展类加载器(Extension Class Loader)：加载<code>$JAVA_HOME/jre/lib/ext</code>目录下的jar包</li><li>应用程序类加载器(Application Class Loader)：加载<code>ClassPath</code>目录下的jar包</li><li>自定义类加载器(User Class Loader)：加载自定义指定目录下的jar包</li></ul><a id="more"></a><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote><p> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p></blockquote><p><img src="http://cdn.mjava.top/blog/20200726204658.jpg" alt></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><blockquote><p>当获取<code>Bootstrap class loader</code>的时候，输出了<code>null</code>，说明<strong>开发者无法通过引用操作启动类加载器</strong></p></blockquote><p><img src="http://cdn.mjava.top/blog/20200726210142.png" alt></p><h2 id="双亲委派机制的作用"><a href="#双亲委派机制的作用" class="headerlink" title="双亲委派机制的作用"></a>双亲委派机制的作用</h2><p>每个加载器都只需要固定的加载自己管理范围内的类，这样的好处就是<code>保证了Java体系的稳定</code>，不然的话你自己定义一个<code>String</code>类的话，这样系统中就会有两个<code>String</code>类，如果没有双亲委派机制的话，系统就不知道到底该加载哪一个，这样系统就变得一片混乱了。</p><h2 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h2><p>双亲委派机制是Java设计者推荐给开发者们的类加载实现方式，并不是一个强制性约束的模型，所以也可以人为的破坏这个机制。</p><ul><li>源码</li></ul><blockquote><p>源码在<code>java.lang.ClassLoader</code>有兴趣的可以去看下</p></blockquote><p><img src="http://cdn.mjava.top/blog/20200726212038.png" alt></p><p>可以看到，就这短短的几行代码，就实现了听起来很高大上的<code>双亲委派机制</code>，所以破坏双亲委派机制的话，就直接重写<code>loadClass</code>方法就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四种类加载器&quot;&gt;&lt;a href=&quot;#四种类加载器&quot; class=&quot;headerlink&quot; title=&quot;四种类加载器&quot;&gt;&lt;/a&gt;四种类加载器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;启动类加载器(Bootstrap Class Loader )：加载&lt;code&gt;$JAVA_HOME/jre/lib&lt;/code&gt;目录下的jar包&lt;/li&gt;
&lt;li&gt;拓展类加载器(Extension Class Loader)：加载&lt;code&gt;$JAVA_HOME/jre/lib/ext&lt;/code&gt;目录下的jar包&lt;/li&gt;
&lt;li&gt;应用程序类加载器(Application Class Loader)：加载&lt;code&gt;ClassPath&lt;/code&gt;目录下的jar包&lt;/li&gt;
&lt;li&gt;自定义类加载器(User Class Loader)：加载自定义指定目录下的jar包&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://mjava.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java类初始化</title>
    <link href="https://mjava.top/java/jvm/java-class-init/"/>
    <id>https://mjava.top/java/jvm/java-class-init/</id>
    <published>2020-09-16T07:01:03.000Z</published>
    <updated>2020-09-16T07:03:46.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码结果？"><a href="#代码结果？" class="headerlink" title="代码结果？"></a>代码结果？</h2><p>首先，我们来看看下面的代码的输出的结果，可以先试着想一下</p><p><img src="http://cdn.mjava.top/blog/20200725004926.png" alt></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line">Code</span><br><span class="line">公众号</span><br></pre></td></tr></table></figure><p>这时候有同学就会想，以前不是说类加载时，静态代码块都会加载的嘛！怎么<code>Test1</code>里的静态代码块没有加载呢？下面就来看看到底怎么回事</p><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>了解类加载前，首先熟悉一下类的生命周期</p><p><img src="http://cdn.mjava.top/blog/20200725003859.png" alt></p><p>这里注意几个点：</p><ul><li><code>解析阶段</code>可以在<code>初始化阶段</code>之后，这是为了支持Java语言的运行时绑定特性（也称为<code>动态绑定</code>或<code>晚期绑定</code>）</li><li>这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</li></ul><a id="more"></a><h2 id="初始化和实例化"><a href="#初始化和实例化" class="headerlink" title="初始化和实例化"></a>初始化和实例化</h2><p>我相信很多人跟我刚开始一样，搞不清他们两个的区别，搞不清<code>new</code>一个对象，到底是对这个对象进行了初始化还是实例化呢？</p><ul><li><p><code>初始化</code>：是完成程序执行前的准备工作。在这个阶段，静态的（变量，方法，代码块）会被执行。同时在会开辟一块存储空间用来存放静态的数据。初始化只在类加载的时候执行<code>一次</code>。</p></li><li><p><code>实例化</code>：是指创建一个对象的过程。这个过程中会在堆中开辟内存，将一些非静态的方法，变量存放在里面。在程序执行的过程中，可以创建多个对象，既多次实例化。每次实例化都会开辟一块新的内存。</p><p><img src="http://cdn.mjava.top/blog/20200725183421.png" alt></p></li></ul><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>《Java虚拟机规范》中并没有对<code>加载</code>进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于<code>初始化阶段</code>，《Java虚拟机规范》则是严格规定了有且只有<code>六种情况</code>必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ul><li><p>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。那到底什么时候能够生成这些指令呢？其实看下字节码就都明白了</p><p><img src="http://cdn.mjava.top/blog/20200725172134.png" alt></p></li><li><p>使用<code>java.lang.reflect</code>包的方法对类型进行<code>反射调用</code>的时候，如果类型没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当初始化类的时候，如果发现其<code>父类</code>还没有进行过初始化，则需要先触发其父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的<code>主类</code>（包含main()方法的那个类），虚拟机会先初始化这个主类。</p></li><li><p>当使用JDK 7新加入的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>、<code>REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当一个接口中定义了<code>JDK 8</code>新加入的默认方法（被<code>default关键字</code>修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ul><blockquote><p><code>java.lang.invoke.MethodHandle</code> 是<code>JDK7</code>中新加入类似反射功能的一个类</p></blockquote><h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><p>对于以上这六种会触发类型进行<code>初始化</code>的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，这六种场景中的行为称为对一个类型进行<code>主动引用</code>。除此之外，所有引用类型的方式都不会触发初始化，称为<code>被动引用。</code></p><p>像文章一开始的代码，就属于被动引用，对于静态字段，<strong>只有直接定义这个字段的类才会被初始化</strong>，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><h3 id="例子1–对象数组"><a href="#例子1–对象数组" class="headerlink" title="例子1–对象数组"></a>例子1–对象数组</h3><p>直接上图</p><p><img src="http://cdn.mjava.top/blog/20200725184328.png" alt></p><p>以上代码执行后并不会输出<code>灰色</code>两个字，因为创建对象数组时并没有去初始化<code>Test1</code>这个类，而是用<code>anewarray</code>字节码指令去初始化了另外一个类，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类。</p><blockquote><p>拓展：数组越界检查没有封装在数组元素的访问类中，而是封装在数组访问的<code>xaload</code>,<code>xastore</code>字节码指令中</p></blockquote><h3 id="例子2–final修饰的静态字段"><a href="#例子2–final修饰的静态字段" class="headerlink" title="例子2–final修饰的静态字段"></a>例子2–final修饰的静态字段</h3><ul><li>被<code>final</code>修饰的静态字段</li></ul><p><img src="http://cdn.mjava.top/blog/20200725194122.png" alt></p><p>此时运行该代码时，只会输出<code>灰色Code</code>字样，<code>Test1</code>并没有触发初始化阶段。这是因为在<code>编译阶段</code>通过<code>常量传播优化</code>，已经将此常量的值<code>灰色Code</code>直接存储在<code>ClassLoadTest</code>类的常量池中，所以当<code>ClassLoadTest</code>类调用<code>Test1</code>里的<code>value</code>时，都变成了对自身常量池的调用，和<code>Test1</code>类没有任何关系。</p><ul><li><p>没有<code>final</code>修饰的静态字段</p><p><img src="http://cdn.mjava.top/blog/20200725194514.png" alt></p></li></ul><p>没有使用<code>final</code>修饰的静态变量，字节码出现了<code>getstatic</code>，所以触发<code>Test1</code>的初始化阶段，此时运行结果将会输出<code>灰色</code>和<code>灰色Code</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码结果？&quot;&gt;&lt;a href=&quot;#代码结果？&quot; class=&quot;headerlink&quot; title=&quot;代码结果？&quot;&gt;&lt;/a&gt;代码结果？&lt;/h2&gt;&lt;p&gt;首先，我们来看看下面的代码的输出的结果，可以先试着想一下&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/blog/20200725004926.png&quot; alt&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;公众号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这时候有同学就会想，以前不是说类加载时，静态代码块都会加载的嘛！怎么&lt;code&gt;Test1&lt;/code&gt;里的静态代码块没有加载呢？下面就来看看到底怎么回事&lt;/p&gt;&lt;h2 id=&quot;类的生命周期&quot;&gt;&lt;a href=&quot;#类的生命周期&quot; class=&quot;headerlink&quot; title=&quot;类的生命周期&quot;&gt;&lt;/a&gt;类的生命周期&lt;/h2&gt;&lt;p&gt;了解类加载前，首先熟悉一下类的生命周期&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/blog/20200725003859.png&quot; alt&gt;&lt;/p&gt;&lt;p&gt;这里注意几个点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;解析阶段&lt;/code&gt;可以在&lt;code&gt;初始化阶段&lt;/code&gt;之后，这是为了支持Java语言的运行时绑定特性（也称为&lt;code&gt;动态绑定&lt;/code&gt;或&lt;code&gt;晚期绑定&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://mjava.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>创建线程的3种方式</title>
    <link href="https://mjava.top/java/thread/create-thread-3/"/>
    <id>https://mjava.top/java/thread/create-thread-3/</id>
    <published>2020-06-22T08:29:38.000Z</published>
    <updated>2020-06-22T08:30:17.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java线程状态变迁图"><a href="#Java线程状态变迁图" class="headerlink" title="Java线程状态变迁图"></a>Java线程状态变迁图</h2><p><img src="http://cdn.mjava.top/blog/20200602150941.jpeg" alt="Java线程状态变迁图"></p><h2 id="构造一个线程"><a href="#构造一个线程" class="headerlink" title="构造一个线程"></a>构造一个线程</h2><p>在线程执行<code>start()</code>方法之前,首先需要初始化(NEW)一个线程,初始化的时候,可以设置线程名称,线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p><p><strong>Thread常见参数及设置方法:</strong></p><ul><li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程是否是守护线程  默认false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     daemon = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//设置方法</span></span><br><span class="line">Thread thread=<span class="keyword">new</span> Thread();</span><br><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程名字默认"Thread-" + nextThreadNum()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"><span class="comment">//设置方法</span></span><br><span class="line">Thread thread=<span class="keyword">new</span> Thread();</span><br><span class="line">thread.setName(<span class="string">"myThread"</span>); <span class="comment">//不能设置为null,会报异常</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程优先级  是否起作用和操作系统及虚拟机版本相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"><span class="comment">//设置方法  范围:1-10  默认5</span></span><br><span class="line">myThread.setPriority(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="Thread源码构造方法"><a href="#Thread源码构造方法" class="headerlink" title="Thread源码构造方法"></a>Thread源码构造方法</h3><p>在Thread源码中,一共提供了<code>9种</code>构造方法.</p><p><img src="http://cdn.mjava.top/blog/20200602151437.png" alt></p><p>从这些构造方法中,大致可以分为<code>有Runnable构造参数</code>的,和<code>无Runnable构造参数</code>两大类,无Runnable构造参数的就需要去继承<code>Thread</code>来重写<code>run()</code>方法<font color="grey">(注:<code>Thread</code>也实现了Runnable接口)</font>,有Runnable构造参数的,就实现Runnable接口的run方法,然后通过构造参数,把实现Runnable接口的实例传入Thread.</p><h3 id="无返回值的线程"><a href="#无返回值的线程" class="headerlink" title="无返回值的线程"></a>无返回值的线程</h3><p>可以看到,通过集成<code>Thread</code>类和实现<code>Runnable</code>接口的<code>run()</code>方法返回值都是<code>void</code>.这类是没有返回值的</p><h4 id="方法一-继承Thread类创建一个线程"><a href="#方法一-继承Thread类创建一个线程" class="headerlink" title="方法一:继承Thread类创建一个线程"></a>方法一:继承Thread类创建一个线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承Thread类,重写run方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"继承Thread,重写run方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-实现Runnable接口创建线程"><a href="#方法二-实现Runnable接口创建线程" class="headerlink" title="方法二:实现Runnable接口创建线程"></a>方法二:实现Runnable接口创建线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口的run方法,然后以构造参数的形式设置Thread的target</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现Runnable方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRun myRun=<span class="keyword">new</span> MyRun();</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(myRun);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有返回值的线程"><a href="#有返回值的线程" class="headerlink" title="有返回值的线程"></a>有返回值的线程</h3><p>上面两个方法,都有一个共同缺点,就是<strong>没有返回值</strong>,当有一些特殊需求时,比如开启一个线程,用来计算一些东西,或者是处理另外一些需要返回数据的业务,这时就需要借助<code>FutureTask</code>来完成了</p><h4 id="方法三-通过FutureTask创建一个线程"><a href="#方法三-通过FutureTask创建一个线程" class="headerlink" title="方法三:通过FutureTask创建一个线程"></a>方法三:通过FutureTask创建一个线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Callable接口的call方法   类似实现Runnable的run方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//计算1+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyCall myCall=<span class="keyword">new</span> MyCall();</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(myCall);</span><br><span class="line">        Thread thread2=<span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//获取线程执行结果</span></span><br><span class="line">        Integer res=futureTask.get();</span><br><span class="line">        System.out.println(res); <span class="comment">//输出2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java线程状态变迁图&quot;&gt;&lt;a href=&quot;#Java线程状态变迁图&quot; class=&quot;headerlink&quot; title=&quot;Java线程状态变迁图&quot;&gt;&lt;/a&gt;Java线程状态变迁图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/blog/20200602150941.jpeg&quot; alt=&quot;Java线程状态变迁图&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;构造一个线程&quot;&gt;&lt;a href=&quot;#构造一个线程&quot; class=&quot;headerlink&quot; title=&quot;构造一个线程&quot;&gt;&lt;/a&gt;构造一个线程&lt;/h2&gt;&lt;p&gt;在线程执行&lt;code&gt;start()&lt;/code&gt;方法之前,首先需要初始化(NEW)一个线程,初始化的时候,可以设置线程名称,线程所属的线程组、线程优先级、是否是Daemon线程等信息。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Thread常见参数及设置方法:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//线程是否是守护线程  默认false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt;     daemon = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Thread thread=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread.setDaemon(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//线程名字	默认&quot;Thread-&quot; + nextThreadNum()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Thread thread=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread.setName(&lt;span class=&quot;string&quot;&gt;&quot;myThread&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//不能设置为null,会报异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//线程优先级  是否起作用和操作系统及虚拟机版本相关&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; priority;																&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置方法  范围:1-10  默认5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myThread.setPriority(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://mjava.top/categories/JAVA/"/>
    
    
      <category term="多线程" scheme="https://mjava.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>吐血整理Git常用命令</title>
    <link href="https://mjava.top/tool/git-tool-command/"/>
    <id>https://mjava.top/tool/git-tool-command/</id>
    <published>2020-06-22T08:27:25.000Z</published>
    <updated>2020-06-22T08:28:15.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git 是用于 Linux<a href="https://baike.baidu.com/item/内核" rel="noopener" target="_blank">内核</a>开发的<a href="https://baike.baidu.com/item/版本控制" rel="noopener" target="_blank">版本控制</a>工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使<a href="https://baike.baidu.com/item/源代码" rel="noopener" target="_blank">源代码</a>的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。</p><a id="more"></a><p>git对于很多人来说,真的是又爱又恨,用的好可以提示开发效率;用不好,解决各种冲突就要累的你半死</p><h2 id="git结构"><a href="#git结构" class="headerlink" title="git结构"></a>git结构</h2><blockquote><p>网上有 我就不画了</p></blockquote><p><img src="http://cdn.mjava.top/blog/20200605001853.png" alt="git结构图"></p><ul><li><p>workspace    相当于就是我们的本地电脑上的文件</p></li><li><p>Index    缓存区</p></li><li><p>Repository    本地仓库</p></li><li><p>Remote    远程仓库(github/gitlab/gitee)</p></li></ul><h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><p>git官方提供的命令多达几百个,可是我们日常却用不到这么多</p><p>所以我就整理了一下日常使用的命令</p><p>现在关注微信公招:<code>灰色Code</code></p><p>回复关键字:<code>git</code></p><p>就可以获取思维导图高清图片及导图源地址</p><p><img src="http://cdn.mjava.top/blog/20200605002904.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git常用命令&quot;&gt;&lt;a href=&quot;#Git常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git常用命令&quot;&gt;&lt;/a&gt;Git常用命令&lt;/h2&gt;&lt;h2 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h2&gt;&lt;p&gt;Git 是用于 Linux&lt;a href=&quot;https://baike.baidu.com/item/内核&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;内核&lt;/a&gt;开发的&lt;a href=&quot;https://baike.baidu.com/item/版本控制&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;版本控制&lt;/a&gt;工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使&lt;a href=&quot;https://baike.baidu.com/item/源代码&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;源代码&lt;/a&gt;的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tool" scheme="https://mjava.top/categories/Tool/"/>
    
    
      <category term="Git" scheme="https://mjava.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>创建一个自定义注解</title>
    <link href="https://mjava.top/spring/apring-aop-ann/"/>
    <id>https://mjava.top/spring/apring-aop-ann/</id>
    <published>2020-06-22T08:23:56.000Z</published>
    <updated>2020-06-22T08:25:48.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时在用springBoot的使用，常常会用到<code>@Service</code>，<code>@Compent</code>等等注解，简化了我们的开发流程，提升了开发效率.那如何自己来写一个注解呢？下面就来介绍一下。</p><h2 id="写一个注解"><a href="#写一个注解" class="headerlink" title="写一个注解"></a>写一个注解</h2><p>创建一个注解主要分两部分，一部分是创建<strong>注解类</strong>，一部分是创建一个<strong>切面类</strong>。</p><h3 id="创建注解类"><a href="#创建注解类" class="headerlink" title="创建注解类"></a>创建注解类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "d"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>创建注解类的关键字就是<code>@interface</code>，这个注解类设置了一个<code>value</code>变量，默认值为d；</p><p>在注解类上面还有<code>@Target</code>和<code>@Retention</code>注解，下面来说说创建注解类时需要用到的几个注解：</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h4><p>用来标记这个注解可以用于哪些地方，与<code>ElementType</code>枚举类搭配使用，那这个枚举类里面有什么内容呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/** 类，接口（包括注释类型）或枚举声明*/</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字段声明（包括枚举常量）*/</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法声明*/</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 形式参数（形参-调用方法时传入的参数）声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造函数声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注释类型声明 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型参数声明</span></span><br><span class="line"><span class="comment">     * java8新特性：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任何类型声明 </span></span><br><span class="line"><span class="comment">     * java8新特性：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><code>@Retention</code></h4><p>该注解表示自定义注解的生命周期</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注释将被编译器丢弃。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注释由编译器记录在类文件中</span></span><br><span class="line"><span class="comment">     * 但不必在运行时由VM保留。 这是默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *注释由编译器记录在类文件中，并且</span></span><br><span class="line"><span class="comment">     *在运行时由VM保留，因此可以以反射方式读取它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个切面类"><a href="#写一个切面类" class="headerlink" title="写一个切面类"></a>写一个切面类</h2><p>因为用到了切面，所以我们要先导入<code>Spring AOP</code>这个依赖包。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot项目导入AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建切面类"><a href="#创建切面类" class="headerlink" title="创建切面类"></a>创建切面类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnAop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger= LoggerFactory.getLogger(MyAnnAop.class);</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.demo.annotation.MyAnn)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ann</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"ann()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"打印：开始前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"ann()"</span>,returning = <span class="string">"res"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">dochange</span><span class="params">(JoinPoint joinPoint,Object res)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"AfterReturning通知开始-获取数据:&#123;&#125;"</span>,res);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        Map&lt;String,String&gt; map= (Map&lt;String, String&gt;) res;</span><br><span class="line">        <span class="comment">//添加新值</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>,<span class="string">"我是在AOP中添加的新值"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-AOP说明"><a href="#Spring-AOP说明" class="headerlink" title="Spring AOP说明"></a>Spring AOP说明</h3><blockquote><p>具体可以查阅Spring AOP相关资料</p></blockquote><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@Before</code></td><td>前置通知，在连接点方法前调用</td></tr><tr><td><code>@Around</code></td><td>环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法</td></tr><tr><td><code>@After</code></td><td>后置通知，在连接点方法后调用</td></tr><tr><td><code>@AfterReturning</code></td><td>返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常</td></tr><tr><td><code>@AfterThrowing</code></td><td>异常通知，当连接点方法异常时调用</td></tr></tbody></table><h2 id="使用自定义的注解"><a href="#使用自定义的注解" class="headerlink" title="使用自定义的注解"></a>使用自定义的注解</h2><p>这里使用普通的<code>SpringBoot</code>来使用注解，创建一个<strong>Service</strong>,在里面使用注解，然后才控制层调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnn</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt;  map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"t1"</span>,<span class="string">"我是在Service设置的值"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制层</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger= LoggerFactory.getLogger(Test2.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; s=testService.test();</span><br><span class="line">        logger.info(<span class="string">"控制层输出：&#123;&#125;"</span>,s.get(<span class="string">"s1"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"sccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.example.demo.aop.MyAnnAop : AfterReturning通知开始-获取数据:&#123;t1=我是在Service设置的值&#125;</span><br><span class="line">com.example.demo.web.Test2    : 控制层输出：我是在AOP中添加的新值</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>上面那样使用注解是没问题的，但是如果是下面这样使用，<code>AOP</code>就会<strong>失效</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger= LoggerFactory.getLogger(Test2.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; s=<span class="keyword">this</span>.test2();</span><br><span class="line">        logger.info(<span class="string">"控制层输出：&#123;&#125;"</span>,s.get(<span class="string">"s1"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"sccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnn</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt;  map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"t1"</span>,<span class="string">"我是在控制层设置的值"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.example.demo.web.Test2       : 控制层输出：null</span><br></pre></td></tr></table></figure><p>这是应为内部方法调用，调用的是具体方法，并没有调用使用AOP后生成的代理方法</p><p>具体参考资料：</p><ul><li><a href="https://blog.csdn.net/Daybreak1209/article/details/82982674" rel="noopener" target="_blank">https://blog.csdn.net/Daybreak1209/article/details/82982674</a></li><li><a href="https://blog.csdn.net/u013151053/article/details/106124048?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" rel="noopener" target="_blank">https://blog.csdn.net/u013151053/article/details/106124048?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></li><li><a href="https://zhewuzhou.github.io/2018/09/01/Spring_AOP_Trap/" rel="noopener" target="_blank">https://zhewuzhou.github.io/2018/09/01/Spring_AOP_Trap/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;平时在用springBoot的使用，常常会用到&lt;code&gt;@Service&lt;/code&gt;，&lt;code&gt;@Compent&lt;/code&gt;等等注解，简化了我们的开发流程，提升了开发效率.那如何自己来写一个注解呢？下面就来介绍一下。&lt;/p&gt;&lt;h2 id=&quot;写一个注解&quot;&gt;&lt;a href=&quot;#写一个注解&quot; class=&quot;headerlink&quot; title=&quot;写一个注解&quot;&gt;&lt;/a&gt;写一个注解&lt;/h2&gt;&lt;p&gt;创建一个注解主要分两部分，一部分是创建&lt;strong&gt;注解类&lt;/strong&gt;，一部分是创建一个&lt;strong&gt;切面类&lt;/strong&gt;。&lt;/p&gt;&lt;h3 id=&quot;创建注解类&quot;&gt;&lt;a href=&quot;#创建注解类&quot; class=&quot;headerlink&quot; title=&quot;创建注解类&quot;&gt;&lt;/a&gt;创建注解类&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(&amp;#123;ElementType.METHOD&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; MyAnn &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &quot;d&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://mjava.top/categories/Spring/"/>
    
    
      <category term="Spring AOP" scheme="https://mjava.top/tags/Spring-AOP/"/>
    
      <category term="注解" scheme="https://mjava.top/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM4种垃圾收集算法</title>
    <link href="https://mjava.top/java/jvm/jvm-gc-alg/"/>
    <id>https://mjava.top/java/jvm/jvm-gc-alg/</id>
    <published>2020-05-29T02:31:30.000Z</published>
    <updated>2020-05-29T02:34:07.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><ul><li><strong>标记过程</strong>就是对象是否属于垃圾的判定过程(<strong>采用可达分析算法GC Roots</strong>)</li><li>算法分为<strong>“标记”</strong>和<strong>“清除”</strong>两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，<strong>也可以反过来</strong>，标记存活的对象，统一回收所有未被标记的对象。</li></ul><a id="more"></a><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>执行效率不稳定，如果Java堆中包含大量对象，而且<strong>其中大部分是需要被回收的</strong>，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的<strong>执行效率都随对象数量增长而降低</strong>；</li><li>第二个是内存空间的碎片化问题，标记、清除之后会<strong>产生大量不连续的内存碎片</strong>，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时<strong>无法找到足够的连续内存</strong>而不得不<strong>提前触发另一次垃圾收集动作</strong>。</li><li><img src="http://cdn.mjava.top/blog/20200529100358.png" alt></li></ul><p><img src="http://cdn.mjava.top/blog/20200528203926.jpeg" alt="标记清除算法"></p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><ul><li><p><strong>标记过程</strong>就是对象是否属于垃圾的判定过程(<strong>采用可达分析算法GC Roots</strong>)</p></li><li><p>它将可用内存按容量划分为<strong>大小相等的两块</strong>，每次只使用其中的一块。</p></li><li><p>当这一块的内存用完了，就将还<strong>存活着的对象复制到另外一块上面</strong>，然后再把<strong>已使用过的内存空间一次清理掉</strong>。</p></li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>如果内存中<strong>多数对象都是存活的</strong>，这种算法将会<strong>产生大量的内存间复制的开销</strong></li><li>代价是将可用内存缩小为了<strong>原来的一半</strong>,空间浪费未免太多了一点.</li><li><img src="http://cdn.mjava.top/blog/20200529100420.jpg" alt></li></ul><p><img src="http://cdn.mjava.top/blog/20200528203952.jpeg" alt="标记复制算法"></p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><ul><li><strong>标记过程</strong>就是对象是否属于垃圾的判定过程(<strong>采用可达分析算法GC Roots</strong>)</li><li>在<strong>标记-清除</strong>的算法基础上改进,后续步骤不是直接对可回收对象进行清理，而是让<strong>所有存活的对象都向内存空间一端移动</strong>，然后直接<strong>清理掉边界以外的内存</strong>，</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>在有大量存活对象的老年代区域,<strong>移动存活对象</strong>并<strong>更新所有引用</strong>这些对象的地方将会是一种<strong>极为负重</strong>的操作,而且这种对象移动操作<strong>必须全程暂停用户应用程序</strong>才能进行,比<strong>标记-清除</strong>算法停顿时间长.</li><li><img src="http://cdn.mjava.top/blog/20200529100506.jpg" alt></li></ul><p><img src="http://cdn.mjava.top/blog/20200528204014.jpeg" alt="标记整理算法"></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>现代商用虚拟机基于以上算法的优缺点,根据<strong>分代收集理论</strong>,在不同的区域采用了不同的收集算法.</p><blockquote><p><font color="red">老年代:新生代=2:1</font></p></blockquote><p><img src="http://cdn.mjava.top/blog/20200529101100.png" alt></p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><blockquote><p>堆大小默认比例:<font color="red">Eden:S0:S1=8:1:1</font></p><p>采用标记-复制算法</p></blockquote><p>新生代分为<strong>Eden区</strong>和<strong>Survior区</strong>,而Survior区又分为<strong>From Survior区(S0)</strong>和<strong>To Survior区(S1)</strong>.此区域采用标记-复制算法.每次Minor GC/Young GC时,会把<strong>Eden区</strong>存活的对象复制到<strong>S0区</strong>,然后清空Eden区,当S0区满时,Eden区和S0区存活的对象会复制到<strong>S1区</strong>,然后S0和S0进行交换,永远保持S1为空状态,当新生代的对象经过一定次数的Minor GC还未被回收时,就会把这个对象移到老年代.</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><blockquote><p>采用标记-整理法或标记-清理法</p></blockquote><p>当老年代Old区域满时,会触发<strong>Full GC</strong>,同时回收新生代和老生代的所有区域.回收后诺内存还是不足时,会引发<strong>OOM异常</strong>;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。&lt;/p&gt;&lt;h2 id=&quot;标记-清除算法&quot;&gt;&lt;a href=&quot;#标记-清除算法&quot; class=&quot;headerlink&quot; title=&quot;标记-清除算法&quot;&gt;&lt;/a&gt;标记-清除算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标记过程&lt;/strong&gt;就是对象是否属于垃圾的判定过程(&lt;strong&gt;采用可达分析算法GC Roots&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;算法分为&lt;strong&gt;“标记”&lt;/strong&gt;和&lt;strong&gt;“清除”&lt;/strong&gt;两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，&lt;strong&gt;也可以反过来&lt;/strong&gt;，标记存活的对象，统一回收所有未被标记的对象。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JAVA四种引用方法使用和对比</title>
    <link href="https://mjava.top/java/jvm/jvm-object-four-quote/"/>
    <id>https://mjava.top/java/jvm/jvm-object-four-quote/</id>
    <published>2020-05-29T02:22:07.000Z</published>
    <updated>2020-05-29T02:37:29.280Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.mjava.top/blog/20200526225718" alt></p><h2 id="强引用（Strongly-Reference）"><a href="#强引用（Strongly-Reference）" class="headerlink" title="强引用（Strongly Reference）"></a>强引用（Strongly Reference）</h2><blockquote><p>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><p><font color="red">回收时机:强引用关系不存在时</font></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h2 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h2><blockquote><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p><font color="red">回收时机:发送内存溢出异常前</font></p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//软引用</span></span><br><span class="line"></span><br><span class="line">SoftReference&lt;Object&gt; srf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"></span><br><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; srf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj=<span class="keyword">null</span>;  <span class="comment">//这种方法一定要设置obj为null,否则这个对象除了软引用可达外,还有原来强引用也可达</span></span><br></pre></td></tr></table></figure><h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h3><blockquote><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生为止</strong>。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p><font color="red">回收时机:下一次垃圾回收时</font></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弱引用</span></span><br><span class="line"></span><br><span class="line">WeakReference&lt;Object&gt; wrf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wrf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line">obj=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h3><blockquote><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><p><font color="red">回收时机:随时</font></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//虚引用</span></span><br><span class="line">PhantomReference&lt;Object&gt; prf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(<span class="keyword">new</span> Object(), <span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"></span><br><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; prf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br><span class="line">obj=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/blog/20200526225718&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;强引用（Strongly-Reference）&quot;&gt;&lt;a href=&quot;#强引用（Strongly-Reference）&quot; class=&quot;headerlink&quot; title=&quot;强引用（Strongly Reference）&quot;&gt;&lt;/a&gt;强引用（Strongly Reference）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;回收时机:强引用关系不存在时&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Object obj=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;软引用（Soft-Reference）&quot;&gt;&lt;a href=&quot;#软引用（Soft-Reference）&quot; class=&quot;headerlink&quot; title=&quot;软引用（Soft Reference）&quot;&gt;&lt;/a&gt;软引用（Soft Reference）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;回收时机:发送内存溢出异常前&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
      <category term="JAVA" scheme="https://mjava.top/categories/JVM/JAVA/"/>
    
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
      <category term="JAVA" scheme="https://mjava.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JVM判断对象是否还活着的两种方法</title>
    <link href="https://mjava.top/java/jvm/jvm-object-is-alive/"/>
    <id>https://mjava.top/java/jvm/jvm-object-is-alive/</id>
    <published>2020-05-29T02:18:30.000Z</published>
    <updated>2020-05-29T02:21:26.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><blockquote><p>Java虚拟机<strong>并不是</strong>通过引用计数算法来判断对象是否存活的。</p></blockquote><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>原理简单,判定效率高</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不能用于复杂的环境中,比如对象的互相引用问题</li></ul><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><a id="more"></a><blockquote><p>Java虚拟机使用此算法来判断对象是否存活</p></blockquote><p>这个算法的基本思路就是通过一系列称为“<code>GC Roots</code>”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，<strong>搜索过程所走过的路径称为“引用链”（Reference Chain）</strong>，如果某个对象到GCRoots间<strong>没有任何引用链相连</strong>，或者用图论的话来说就是<strong>从GC Roots到这个对象不可达时</strong>，则证明<strong>此对象是不可能再被使用的</strong>。</p><p><img src="http://cdn.mjava.top/blog/20200526224246.jpeg" alt></p><p>Java中作为GC Roots的对象:</p><ul><li><p>在虚拟机栈（<strong>栈帧中的本地变量表</strong>）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p></li><li><p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</p></li><li><p>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</p></li><li><p>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p></li><li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p></li><li><p>所有被同步锁（synchronized关键字）持有的对象。</p></li><li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p></li><li><p><strong>其他对象临时性地加入,共同构成GC Roots</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引用计数法&quot;&gt;&lt;a href=&quot;#引用计数法&quot; class=&quot;headerlink&quot; title=&quot;引用计数法&quot;&gt;&lt;/a&gt;引用计数法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Java虚拟机&lt;strong&gt;并不是&lt;/strong&gt;通过引用计数算法来判断对象是否存活的。&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。&lt;/p&gt;&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;原理简单,判定效率高&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点&quot;&gt;&lt;/a&gt;缺点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不能用于复杂的环境中,比如对象的互相引用问题&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可达性分析算法&quot;&gt;&lt;a href=&quot;#可达性分析算法&quot; class=&quot;headerlink&quot; title=&quot;可达性分析算法&quot;&gt;&lt;/a&gt;可达性分析算法&lt;/h2&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域</title>
    <link href="https://mjava.top/java/jvm/jvm-running-data-area/"/>
    <id>https://mjava.top/java/jvm/jvm-running-data-area/</id>
    <published>2020-05-26T08:35:47.000Z</published>
    <updated>2020-05-26T08:36:31.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM运行时数据区域"><a href="#JVM运行时数据区域" class="headerlink" title="JVM运行时数据区域"></a>JVM运行时数据区域</h1><p><img src="http://cdn.mjava.top/blog/20200526000623.jpeg" alt="Java虚拟机运行时数据区"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li><p>线程私有</p></li><li><p>唯一一个没有规定 OutOfMemoryError 异常 的区域</p></li><li><p>它可以看作是当前线程所执行的字节码的行号指示器</p></li><li><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）</p></li></ul><a id="more"></a><blockquote><p>(摘自网上)我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？</p><p>答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；<strong>程序计数器里面保存的是 当前线程执行的字节码的行号</strong>（看着像行号，其实是指令地址）；</p><p>那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，因此，<strong>程序计数器的内存空间是线程私</strong>有的 ；这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！</p><p>那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！因此，线程计数器，必须是<strong>线程被创建开始执行的时候，就要一同被创建</strong>； </p><p>程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此，jvm虚拟机规范，也就没有规定，也是<strong>唯一一个没有规定 OutOfMemoryError 异常 的区域</strong>;</p><p><strong>当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）</strong>；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录 </p></blockquote><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul><li>线程私有</li><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError异常</code>；</li><li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError异常</code>；(<font color="red">HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的</font>)</li><li><strong>-Xss5m</strong>:    设置5m的栈容量</li><li>每个方法执行都会创建一个<strong>栈帧</strong>，栈帧包含局部变量表、操作数栈、动态连接、方法出口等</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li><p>线程私有</p></li><li><p>与Java虚拟机栈相似</p></li><li><p>与Java虚拟机栈区别:    Java虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p></li><li><p>Hot-Spot虚拟机直接就把本地方法栈和虚拟机栈合二为一</p></li><li><p>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常</p></li></ul><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul><li>线程共享</li><li>所有的Java对象实例不一定都在Java堆上分配内存</li><li>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数<code>-Xmx</code>和<code>-Xms</code>设定）。</li><li>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<strong>OutOfMemoryError异常</strong>。</li><li>Java堆是垃圾收集器(Garbage Collected)管理的内存区域</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li><p>线程共享</p></li><li><p>用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p></li><li><p>虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作<strong>“非堆”（Non-Heap）</strong>，目的是<strong>与Java堆区分开来</strong>。</p></li><li><p>在JDK1.6及之前,使用<code>永久代</code>来实现方法区.</p><ul><li>-XX:MaxPermSize    设置永久代内存上限</li><li>-XX:PermSize    设置永久代内存</li></ul></li><li><p>JDK1.7把<code>字符串常量池</code>、<code>类的静态变量(class statics)</code>转移到了java heap,但是永久代还是存在,主要放一些类信息(<code>运算时常量池</code>)等.</p></li></ul><ul><li><p>JDK1.8彻底移除永久代,方法区采用本地内存中实现的元空间（Meta-space）来代替,将JDK1.7中永久代的信息移到了元空间,像<code>字符串常量池</code>和<code>静态变量</code>还是存在Java Heap中</p></li><li><p>如果方法区无法满足新的内存分配需求时，将抛出<strong>OutOfMemoryError异常</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM运行时数据区域&quot;&gt;&lt;a href=&quot;#JVM运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;JVM运行时数据区域&quot;&gt;&lt;/a&gt;JVM运行时数据区域&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/blog/20200526000623.jpeg&quot; alt=&quot;Java虚拟机运行时数据区&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程私有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;唯一一个没有规定 OutOfMemoryError 异常 的区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它可以看作是当前线程所执行的字节码的行号指示器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM逃逸分析技术</title>
    <link href="https://mjava.top/java/jvm/jvm-javastack-EscapeAnalysis/"/>
    <id>https://mjava.top/java/jvm/jvm-javastack-EscapeAnalysis/</id>
    <published>2020-05-26T08:02:00.000Z</published>
    <updated>2020-05-26T08:05:40.964Z</updated>
    
    <content type="html"><![CDATA[<p>逃逸分析技术的日渐成熟,促使所有的Java对象实例不一定都在Java堆上分配内存</p><p>简单来讲就是，Java Hotspot 虚拟机可以分析<strong>新创建对象</strong>的使用范围，并决定是否在 Java 堆上分配内存的一项技术。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li><li>逃逸分析技术在 Java SE 6u23+ 开始支持,并默认设置为启用状态</li></ul><a id="more"></a><h2 id="逃逸程度"><a href="#逃逸程度" class="headerlink" title="逃逸程度"></a>逃逸程度</h2><p>逸分析的基本行为就是分析对象动态作用域,从<strong>不逃逸</strong>、<strong>方法逃逸</strong>到<strong>线程逃逸</strong>，称为对象<strong>由低到高的不同逃逸程度</strong>。</p><h3 id="方法逃逸"><a href="#方法逃逸" class="headerlink" title="方法逃逸"></a>方法逃逸</h3><p>当一个对象在<strong>方法中</strong>被定义后，它可能被<strong>外部方法</strong>所引用，例如作为调用参数传递到其他地方中，称为<strong>方法逃逸</strong>。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所</span></span><br><span class="line"><span class="comment">*改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线</span></span><br><span class="line"><span class="comment">*程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">     StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">     sb.append(s1);</span><br><span class="line">     sb.append(s2);</span><br><span class="line">     <span class="keyword">return</span> sb;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">     StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">     sb.append(s1);</span><br><span class="line">     sb.append(s2);</span><br><span class="line">     <span class="keyword">return</span> sb.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="线程逃逸"><a href="#线程逃逸" class="headerlink" title="线程逃逸"></a>线程逃逸</h3><ul><li>当一个对象在<strong>方法中</strong>被定义后，它可能被<strong>外部线程</strong>访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为<strong>线程逃逸</strong>。</li></ul><h2 id="逃逸分析优化"><a href="#逃逸分析优化" class="headerlink" title="逃逸分析优化"></a>逃逸分析优化</h2><p>如果能<strong>证明一个对象不会逃逸到方法或线程之外</strong>（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者<strong>逃逸程度比较低</strong>（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例<strong>采取不同程度的优化</strong></p><h3 id="栈上分配（Stack-Allocations）"><a href="#栈上分配（Stack-Allocations）" class="headerlink" title="栈上分配（Stack Allocations）"></a>栈上分配（Stack Allocations）</h3><ul><li>如果确定一个对象<strong>不会逃逸出线程之外</strong>，那让这个对象在<strong>栈上分配内存</strong>将会是一个很不错的主意，对象所占用的内存空间就可以<strong>随栈帧出栈而销毁</strong>。</li><li>由于复杂度等原因，HotSpot中目前暂时还没有做这项优化，但一些其他的虚拟机（如Excelsior JET）使用了这项优化。</li><li>栈上分配可以支持方法逃逸，但不能支持线程逃逸。</li></ul><h3 id="标量替换（Scalar-Replacement）"><a href="#标量替换（Scalar-Replacement）" class="headerlink" title="标量替换（Scalar Replacement）"></a>标量替换（Scalar Replacement）</h3><ul><li>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为<strong>标量</strong>。相对的，如果一个数据可以继续分解，那它就被称为<strong>聚合量（Aggregate）</strong>，Java中的对象就是典型的聚合量。</li><li>-XX:+EliminateAllocations    开启标量替换(jdk8默认开启)</li><li>-XX:+PrintEliminateAllocations    查看标量的替换情况</li><li>如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为<strong>标量替换</strong></li><li>假如逃逸分析能够证明一个对象<strong>不会被方法外部访问</strong>，并且这个对象可以被拆散，那么程序真正执行的时候将<strong>可能不去创建这个对象</strong>，而改为直接创建它的若干个被这个方法使用的<strong>成员变量</strong>来代替。</li><li>标量替换可以视作<strong>栈上分配的一种特例</strong>，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它<strong>不允许对象逃逸出方法范围内</strong>。</li></ul><h3 id="同步消除（Synchronization-Elimination）"><a href="#同步消除（Synchronization-Elimination）" class="headerlink" title="同步消除（Synchronization Elimination）"></a>同步消除（Synchronization Elimination）</h3><blockquote><p>也叫锁消除</p></blockquote><ul><li>+XX:+EliminateLocks    开启同步消除(jdk8默认开启)</li><li>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量<strong>不会逃逸出线程</strong>，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的<strong>同步措施</strong>也就可以<strong>安全地消除掉</strong>。</li><li>比如常用的线程安全类:<code>StringBuffer</code>,<code>HashTable</code>,<code>Vector</code>等.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;逃逸分析技术的日渐成熟,促使所有的Java对象实例不一定都在Java堆上分配内存&lt;/p&gt;&lt;p&gt;简单来讲就是，Java Hotspot 虚拟机可以分析&lt;strong&gt;新创建对象&lt;/strong&gt;的使用范围，并决定是否在 Java 堆上分配内存的一项技术。&lt;/p&gt;&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;开启逃逸分析：-XX:+DoEscapeAnalysis&lt;/li&gt;
&lt;li&gt;关闭逃逸分析：-XX:-DoEscapeAnalysis&lt;/li&gt;
&lt;li&gt;显示分析结果：-XX:+PrintEscapeAnalysis&lt;/li&gt;
&lt;li&gt;逃逸分析技术在 Java SE 6u23+ 开始支持,并默认设置为启用状态&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://mjava.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://mjava.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>基于SpringCloud搭建Spring-security-oauth认证服务器</title>
    <link href="https://mjava.top/archive/web-security/spring-security-oauth-server-demo/"/>
    <id>https://mjava.top/archive/web-security/spring-security-oauth-server-demo/</id>
    <published>2020-05-19T12:25:06.000Z</published>
    <updated>2020-09-16T07:12:57.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>这里搭建一个用OAuth2.0密码模式认证的服务器，token存入redis，client存入Mysql；</p><p>所以事先要准备好：</p><ul><li>Redis</li><li>Mysql</li></ul><p>并且Mysql执行<a href="https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql" rel="noopener" target="_blank">Spring-security-oauth初始化Sql</a>这个SQL，初始化Spring-security-oauth所需要的表。然后执行</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入client_id和client_secret都为sunline的客户端</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> </span><br><span class="line">oauth_client_details (client_id, client_secret, authorized_grant_types , autoapprove)</span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">(<span class="string">"sunline"</span>,<span class="string">"&#123;bcrypt&#125;$2a$10$G1CFd535SiyOtvi6ckbZWexQy.hW5x/I/fLBPiW/E4UmctCfKYbgG"</span>,<span class="string">"password"</span>,<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>client_secret为<code>new BCryptPasswordEncoder().encode(&quot;sunline&quot;)</code>方法加密后，然后在加上<code>{bcrypt}</code></p></blockquote><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="导入pom依赖"><a href="#导入pom依赖" class="headerlink" title="导入pom依赖"></a>导入pom依赖</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--security-oauth--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--redis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--mysql--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.0.17&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置application-properties"><a href="#配置application-properties" class="headerlink" title="配置application.properties"></a>配置application.properties</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#datasource</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3307/grey_code?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">zmh</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">zmh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">9991</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/oauthServer</span></span><br></pre></td></tr></table></figure><h3 id="创建用户详情服务类"><a href="#创建用户详情服务类" class="headerlink" title="创建用户详情服务类"></a>创建用户详情服务类</h3><p><img src="http://cdn.mjava.top/blog/20200519194059.png" alt></p><h4 id="创建权限控制类"><a href="#创建权限控制类" class="headerlink" title="创建权限控制类"></a>创建权限控制类</h4><p><img src="http://cdn.mjava.top/blog/20200519194128.png" alt></p><h3 id="创建认证授权类"><a href="#创建认证授权类" class="headerlink" title="创建认证授权类"></a>创建认证授权类</h3><p><img src="http://cdn.mjava.top/blog/20200519194207.png" alt></p><h2 id="获取令牌"><a href="#获取令牌" class="headerlink" title="获取令牌"></a>获取令牌</h2><p>访问:<code>/oauth/token</code>就可以获取到令牌</p><p><img src="http://cdn.mjava.top/blog/20200519194446.png" alt></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"accessToken"</span>: <span class="string">"e28f9a99-e60d-4693-b6c3-73e06a1d14f5ZMH10086"</span>,</span><br><span class="line">    <span class="attr">"expiration"</span>: <span class="string">"2020-05-19T21:11:39.883+0000"</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: [</span><br><span class="line">        <span class="string">"all"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"tokenType"</span>: <span class="string">"bearer"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问资源"><a href="#访问资源" class="headerlink" title="访问资源"></a>访问资源</h3><p>带上获取到的令牌</p><p><img src="http://cdn.mjava.top/blog/20200519194803.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备阶段&quot;&gt;&lt;a href=&quot;#准备阶段&quot; class=&quot;headerlink&quot; title=&quot;准备阶段&quot;&gt;&lt;/a&gt;准备阶段&lt;/h2&gt;&lt;p&gt;这里搭建一个用OAuth2.0密码模式认证的服务器，token存入redis，client存入Mysql；&lt;/p&gt;&lt;p&gt;所以事先要准备好：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Mysql&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并且Mysql执行&lt;a href=&quot;https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Spring-security-oauth初始化Sql&lt;/a&gt;这个SQL，初始化Spring-security-oauth所需要的表。然后执行&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebSecurity" scheme="https://mjava.top/categories/WebSecurity/"/>
    
    
      <category term="OAuth" scheme="https://mjava.top/tags/OAuth/"/>
    
      <category term="spring-security" scheme="https://mjava.top/tags/spring-security/"/>
    
  </entry>
  
  <entry>
    <title>SSO单点登录和CAS框架</title>
    <link href="https://mjava.top/archive/web-security/sso-and-cas/"/>
    <id>https://mjava.top/archive/web-security/sso-and-cas/</id>
    <published>2020-05-14T11:27:14.000Z</published>
    <updated>2020-05-14T11:29:21.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSO单点登录"><a href="#SSO单点登录" class="headerlink" title="SSO单点登录"></a>SSO单点登录</h2><p><strong>单点登录</strong>（英语：Single sign-on，缩写为 SSO），又译为<strong>单一签入</strong>，一种对于许多相互关连，但是又是各自独立的软件系统，提供<a href="https://zh.wikipedia.org/wiki/存取控制" rel="noopener" target="_blank">访问控制</a>的属性。当拥有这项属性时，当用户<a href="https://zh.wikipedia.org/wiki/登入" rel="noopener" target="_blank">登录</a>时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。这项功能通常是以<a href="https://zh.wikipedia.org/wiki/轻型目录访问协议" rel="noopener" target="_blank">轻型目录访问协议</a>（LDAP）来实现，在服务器上会将用户信息存储到LDAP数据库中。相同的，<strong>单一退出</strong>（single sign-off）就是指，只需要单一的退出动作，就可以结束对于多个系统的访问权限。</p><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>使用单点登录的好处包括：</p><ul><li>降低访问第三方网站的风险（不存储用户密码，或在外部管理）。</li><li>减少因不同的用户名和密码组合而带来的<a href="https://zh.wikipedia.org/w/index.php?title=密碼疲勞&action=edit&redlink=1" rel="noopener" target="_blank">密码疲劳</a>。</li><li>减少为相同的身份重新输入密码所花费的时间。</li><li>因减少与密码相关的调用IT<a href="https://zh.wikipedia.org/wiki/服务台" rel="noopener" target="_blank">服务台</a>的次数而降低IT成本。<a href="https://zh.wikipedia.org/wiki/單一登入#cite_note-1" rel="noopener" target="_blank">[1]</a></li></ul><p>SSO为所有其它应用程序和系统，以集中的<a href="https://zh.wikipedia.org/w/index.php?title=验证服务器&action=edit&redlink=1" rel="noopener" target="_blank">验证服务器</a>提供身份验证，并结合技术以确保用户不必频繁输入密码。</p><h2 id="CAS框架"><a href="#CAS框架" class="headerlink" title="CAS框架"></a>CAS框架</h2><p>CAS 协议基于在<strong>客户端</strong>Web浏览器、Web<strong>应用</strong>和<strong>CAS服务器</strong>之间的票据验证。当客户端访问访问应用程序，请求身份验证时，应用程序重定向到CAS。CAS验证客户端是否被授权，通常通过在数据库对用户名和密码进行检查。如果身份验证成功，CAS一次性在客户端以Cookie形式发放TGT票据，在其有效期CAS将一直信任用户，同时将客户端自动返回到应用程序，并向应用传递身份验证票（Service ticket）。然后，应用程序通过安全连接连接CAS，并提供自己的服务标识和验证票。之后CAS给出了关于特定用户是否已成功通过身份验证的应用程序授信信息。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li><p>CAS是由<a href="https://zh.wikipedia.org/wiki/耶鲁大学" rel="noopener" target="_blank">耶鲁大学</a><a href="https://zh.wikipedia.org/wiki/集中式认证服务#cite_note-1" rel="noopener" target="_blank">[1]</a>的Shawn Bayern创始的，后来由耶鲁大学的Drew Mazurek维护。CAS1.0实现了单点登录。 CAS2.0引入了多级代理认证（Multi-tier proxy authentication）。CAS其他几个版本已经有了新的功能。</p></li><li><p>2004年12月，CAS成为<a href="https://zh.wikipedia.org/w/index.php?title=Jasig&action=edit&redlink=1" rel="noopener" target="_blank">Jasig</a><a href="https://zh.wikipedia.org/wiki/集中式认证服务#cite_note-2" rel="noopener" target="_blank">[2]</a>的一个项目，2008年该组织负责CAS的维护和发展。CAS原名“耶鲁大学CAS”，此后被称为“Jasig CAS”。</p></li><li><p>2005年5月，CAS协议版本2发布，引入代理和服务验证。</p></li><li><p>2006年12月，<a href="https://zh.wikipedia.org/w/index.php?title=安德鲁·W·梅隆基金会&action=edit&redlink=1" rel="noopener" target="_blank">安德鲁·W·梅隆基金会</a>授予耶鲁大学第一届梅隆技术协作奖，颁发50000美元的奖金对耶鲁大学开发CAS进行奖励。<a href="https://zh.wikipedia.org/wiki/集中式认证服务#cite_note-3" rel="noopener" target="_blank">[3]</a>颁奖之时，CAS在“数以百计的大学校园”中使用。</p></li><li><p>2012年12月，JASIG与Sakai基金合并，CAS改名为Apereo CAS。</p></li><li><p>2016年11月，基于Spring Boot的CAS软件版本5发布。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SSO单点登录&quot;&gt;&lt;a href=&quot;#SSO单点登录&quot; class=&quot;headerlink&quot; title=&quot;SSO单点登录&quot;&gt;&lt;/a&gt;SSO单点登录&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单点登录&lt;/strong&gt;（英语：Single sign-on，缩写为 SSO），又译为&lt;strong&gt;单一签入&lt;/strong&gt;，一种对于许多相互关连，但是又是各自独立的软件系统，提供&lt;a href=&quot;https://zh.wikipedia.org/wiki/存取控制&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;访问控制&lt;/a&gt;的属性。当拥有这项属性时，当用户&lt;a href=&quot;https://zh.wikipedia.org/wiki/登入&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;登录&lt;/a&gt;时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。这项功能通常是以&lt;a href=&quot;https://zh.wikipedia.org/wiki/轻型目录访问协议&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;轻型目录访问协议&lt;/a&gt;（LDAP）来实现，在服务器上会将用户信息存储到LDAP数据库中。相同的，&lt;strong&gt;单一退出&lt;/strong&gt;（single sign-off）就是指，只需要单一的退出动作，就可以结束对于多个系统的访问权限。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebSecurity" scheme="https://mjava.top/categories/WebSecurity/"/>
    
    
      <category term="SSO" scheme="https://mjava.top/tags/SSO/"/>
    
      <category term="CAS框架" scheme="https://mjava.top/tags/CAS%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
